{"version":3,"sources":["../src/tools/tool-builder/builder.ts","../src/utils.ts"],"names":["error","logger","z","delay"],"mappings":"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","file":"chunk-WWQ3QRPF.js","sourcesContent":["import type { ToolCallOptions } from '@ai-sdk/provider-utils-v5';\nimport {\n  OpenAIReasoningSchemaCompatLayer,\n  OpenAISchemaCompatLayer,\n  GoogleSchemaCompatLayer,\n  AnthropicSchemaCompatLayer,\n  DeepSeekSchemaCompatLayer,\n  MetaSchemaCompatLayer,\n  applyCompatLayer,\n  convertZodSchemaToAISDKSchema,\n} from '@mastra/schema-compat';\nimport type { ToolExecutionOptions } from 'ai';\nimport { z } from 'zod';\nimport { AISpanType } from '../../ai-tracing';\nimport { MastraBase } from '../../base';\nimport { ErrorCategory, MastraError, ErrorDomain } from '../../error';\nimport { RuntimeContext } from '../../runtime-context';\nimport { isVercelTool } from '../../tools/toolchecks';\nimport type { ToolOptions } from '../../utils';\nimport { ToolStream } from '../stream';\nimport type { CoreTool, ToolAction, VercelTool, VercelToolV5 } from '../types';\nimport { validateToolInput } from '../validation';\n\nexport type ToolToConvert = VercelTool | ToolAction<any, any, any> | VercelToolV5;\nexport type LogType = 'tool' | 'toolset' | 'client-tool';\n\ninterface LogOptions {\n  agentName?: string;\n  toolName: string;\n  type?: 'tool' | 'toolset' | 'client-tool';\n}\n\ninterface LogMessageOptions {\n  start: string;\n  error: string;\n}\n\nexport class CoreToolBuilder extends MastraBase {\n  private originalTool: ToolToConvert;\n  private options: ToolOptions;\n  private logType?: LogType;\n\n  constructor(input: { originalTool: ToolToConvert; options: ToolOptions; logType?: LogType }) {\n    super({ name: 'CoreToolBuilder' });\n    this.originalTool = input.originalTool;\n    this.options = input.options;\n    this.logType = input.logType;\n  }\n\n  // Helper to get parameters based on tool type\n  private getParameters = () => {\n    if (isVercelTool(this.originalTool)) {\n      return this.originalTool.parameters ?? z.object({});\n    }\n\n    return this.originalTool.inputSchema ?? z.object({});\n  };\n\n  private getOutputSchema = () => {\n    if ('outputSchema' in this.originalTool) return this.originalTool.outputSchema;\n    return null;\n  };\n\n  // For provider-defined tools, we need to include all required properties\n  private buildProviderTool(tool: ToolToConvert): (CoreTool & { id: `${string}.${string}` }) | undefined {\n    if (\n      'type' in tool &&\n      tool.type === 'provider-defined' &&\n      'id' in tool &&\n      typeof tool.id === 'string' &&\n      tool.id.includes('.')\n    ) {\n      const parameters = this.getParameters();\n      const outputSchema = this.getOutputSchema();\n      return {\n        type: 'provider-defined' as const,\n        id: tool.id,\n        args: ('args' in this.originalTool ? this.originalTool.args : {}) as Record<string, unknown>,\n        description: tool.description,\n        parameters: convertZodSchemaToAISDKSchema(parameters),\n        ...(outputSchema ? { outputSchema: convertZodSchemaToAISDKSchema(outputSchema) } : {}),\n        execute: this.originalTool.execute\n          ? this.createExecute(\n              this.originalTool,\n              { ...this.options, description: this.originalTool.description },\n              this.logType,\n            )\n          : undefined,\n      };\n    }\n\n    return undefined;\n  }\n\n  private createLogMessageOptions({ agentName, toolName, type }: LogOptions): LogMessageOptions {\n    // If no agent name, use default format\n    if (!agentName) {\n      return {\n        start: `Executing tool ${toolName}`,\n        error: `Failed tool execution`,\n      };\n    }\n\n    const prefix = `[Agent:${agentName}]`;\n    const toolType = type === 'toolset' ? 'toolset' : 'tool';\n\n    return {\n      start: `${prefix} - Executing ${toolType} ${toolName}`,\n      error: `${prefix} - Failed ${toolType} execution`,\n    };\n  }\n\n  private createExecute(tool: ToolToConvert, options: ToolOptions, logType?: 'tool' | 'toolset' | 'client-tool') {\n    // dont't add memory or mastra to logging\n    const { logger, mastra: _mastra, memory: _memory, runtimeContext, ...rest } = options;\n\n    const { start, error } = this.createLogMessageOptions({\n      agentName: options.agentName,\n      toolName: options.name,\n      type: logType,\n    });\n\n    const execFunction = async (args: unknown, execOptions: ToolExecutionOptions | ToolCallOptions) => {\n      // Create tool span if we have an current span available\n      const toolSpan = options.tracingContext.currentSpan?.createChildSpan({\n        type: AISpanType.TOOL_CALL,\n        name: `tool: ${options.name}`,\n        input: args,\n        attributes: {\n          toolId: options.name,\n          toolDescription: options.description,\n          toolType: logType || 'tool',\n        },\n      });\n\n      try {\n        let result;\n\n        if (isVercelTool(tool)) {\n          // Handle Vercel tools (AI SDK tools)\n          result = await tool?.execute?.(args, execOptions as ToolExecutionOptions);\n        } else {\n          // Handle Mastra tools\n          result = await tool?.execute?.(\n            {\n              context: args,\n              threadId: options.threadId,\n              resourceId: options.resourceId,\n              mastra: options.mastra,\n              memory: options.memory,\n              runId: options.runId,\n              runtimeContext: options.runtimeContext ?? new RuntimeContext(),\n              writer: new ToolStream(\n                {\n                  prefix: 'tool',\n                  callId: execOptions.toolCallId,\n                  name: options.name,\n                  runId: options.runId!,\n                },\n                options.writableStream || (execOptions as any).writableStream,\n              ),\n              tracingContext: { currentSpan: toolSpan },\n            },\n            execOptions as ToolExecutionOptions & ToolCallOptions,\n          );\n        }\n\n        toolSpan?.end({ output: result });\n        return result ?? undefined;\n      } catch (error) {\n        toolSpan?.error({ error: error as Error });\n        throw error;\n      }\n    };\n\n    return async (args: unknown, execOptions?: ToolExecutionOptions | ToolCallOptions) => {\n      let logger = options.logger || this.logger;\n      try {\n        logger.debug(start, { ...rest, args });\n\n        // Validate input parameters if schema exists\n        const parameters = this.getParameters();\n        const { data, error } = validateToolInput(parameters, args, options.name);\n        if (error) {\n          logger.warn(`Tool input validation failed for '${options.name}'`, {\n            toolName: options.name,\n            errors: error.validationErrors,\n            args,\n          });\n          return error;\n        }\n        // Use validated/transformed data\n        args = data;\n\n        // there is a small delay in stream output so we add an immediate to ensure the stream is ready\n        return await new Promise((resolve, reject) => {\n          setImmediate(async () => {\n            try {\n              const result = await execFunction(args, execOptions!);\n              resolve(result);\n            } catch (err) {\n              reject(err);\n            }\n          });\n        });\n      } catch (err) {\n        const mastraError = new MastraError(\n          {\n            id: 'TOOL_EXECUTION_FAILED',\n            domain: ErrorDomain.TOOL,\n            category: ErrorCategory.USER,\n            details: {\n              errorMessage: String(error),\n              argsJson: JSON.stringify(args),\n              model: rest.model?.modelId ?? '',\n            },\n          },\n          err,\n        );\n        logger.trackException(mastraError);\n        logger.error(error, { ...rest, error: mastraError, args });\n        return mastraError;\n      }\n    };\n  }\n\n  buildV5() {\n    const builtTool = this.build();\n\n    if (!builtTool.parameters) {\n      throw new Error('Tool parameters are required');\n    }\n\n    return {\n      ...builtTool,\n      inputSchema: builtTool.parameters,\n      onInputStart: 'onInputStart' in this.originalTool ? this.originalTool.onInputStart : undefined,\n      onInputDelta: 'onInputDelta' in this.originalTool ? this.originalTool.onInputDelta : undefined,\n      onInputAvailable: 'onInputAvailable' in this.originalTool ? this.originalTool.onInputAvailable : undefined,\n    } as VercelToolV5;\n  }\n\n  build(): CoreTool {\n    const providerTool = this.buildProviderTool(this.originalTool);\n    if (providerTool) {\n      return providerTool;\n    }\n\n    const definition = {\n      type: 'function' as const,\n      description: this.originalTool.description,\n      parameters: this.getParameters(),\n      outputSchema: this.getOutputSchema(),\n      execute: this.originalTool.execute\n        ? this.createExecute(\n            this.originalTool,\n            { ...this.options, description: this.originalTool.description },\n            this.logType,\n          )\n        : undefined,\n    };\n\n    const model = this.options.model;\n\n    const schemaCompatLayers = [];\n\n    if (model) {\n      const supportsStructuredOutputs =\n        model.specificationVersion !== 'v2' ? (model.supportsStructuredOutputs ?? false) : false;\n\n      const modelInfo = {\n        modelId: model.modelId,\n        supportsStructuredOutputs,\n        provider: model.provider,\n      };\n\n      schemaCompatLayers.push(\n        new OpenAIReasoningSchemaCompatLayer(modelInfo),\n        new OpenAISchemaCompatLayer(modelInfo),\n        new GoogleSchemaCompatLayer(modelInfo),\n        new AnthropicSchemaCompatLayer(modelInfo),\n        new DeepSeekSchemaCompatLayer(modelInfo),\n        new MetaSchemaCompatLayer(modelInfo),\n      );\n    }\n\n    const processedSchema = applyCompatLayer({\n      schema: this.getParameters(),\n      compatLayers: schemaCompatLayers,\n      mode: 'aiSdkSchema',\n    });\n\n    let processedOutputSchema;\n\n    if (this.getOutputSchema()) {\n      processedOutputSchema = applyCompatLayer({\n        schema: this.getOutputSchema(),\n        compatLayers: schemaCompatLayers,\n        mode: 'aiSdkSchema',\n      });\n    }\n\n    return {\n      ...definition,\n      id: 'id' in this.originalTool ? this.originalTool.id : undefined,\n      parameters: processedSchema,\n      outputSchema: processedOutputSchema,\n    };\n  }\n}\n","import { createHash } from 'crypto';\nimport type { WritableStream } from 'stream/web';\nimport type { CoreMessage } from 'ai';\nimport jsonSchemaToZod from 'json-schema-to-zod';\nimport { z } from 'zod';\nimport type { MastraPrimitives } from './action';\nimport type { ToolsInput } from './agent';\nimport type { TracingContext } from './ai-tracing';\nimport type { IMastraLogger } from './logger';\nimport type { Mastra } from './mastra';\nimport type { AiMessageType, MastraLanguageModel, MastraMemory } from './memory';\nimport type { RuntimeContext } from './runtime-context';\nimport type { ChunkType } from './stream/types';\nimport type { CoreTool, VercelTool, VercelToolV5 } from './tools';\nimport { CoreToolBuilder } from './tools/tool-builder/builder';\nimport type { ToolToConvert } from './tools/tool-builder/builder';\nimport { isVercelTool } from './tools/toolchecks';\n\nexport const delay = (ms: number) => new Promise(resolve => setTimeout(resolve, ms));\n\n/**\n * Deep merges two objects, recursively merging nested objects and arrays\n */\nexport function deepMerge<T extends object = object>(target: T, source: Partial<T>): T {\n  const output = { ...target };\n\n  if (!source) return output;\n\n  Object.keys(source).forEach(key => {\n    const targetValue = output[key as keyof T];\n    const sourceValue = source[key as keyof T];\n\n    if (Array.isArray(targetValue) && Array.isArray(sourceValue)) {\n      (output as any)[key] = sourceValue;\n    } else if (\n      sourceValue instanceof Object &&\n      targetValue instanceof Object &&\n      !Array.isArray(sourceValue) &&\n      !Array.isArray(targetValue)\n    ) {\n      (output as any)[key] = deepMerge(targetValue, sourceValue as T);\n    } else if (sourceValue !== undefined) {\n      (output as any)[key] = sourceValue;\n    }\n  });\n\n  return output;\n}\n\nexport function generateEmptyFromSchema(schema: string) {\n  try {\n    const parsedSchema = JSON.parse(schema);\n    if (!parsedSchema || parsedSchema.type !== 'object' || !parsedSchema.properties) return {};\n    const obj: Record<string, any> = {};\n    const TYPE_DEFAULTS = {\n      string: '',\n      array: [],\n      object: {},\n      number: 0,\n      integer: 0,\n      boolean: false,\n    };\n    for (const [key, prop] of Object.entries<any>(parsedSchema.properties)) {\n      obj[key] = TYPE_DEFAULTS[prop.type as keyof typeof TYPE_DEFAULTS] ?? null;\n    }\n    return obj;\n  } catch {\n    return {};\n  }\n}\n\nexport interface TagMaskOptions {\n  /** Called when masking begins */\n  onStart?: () => void;\n  /** Called when masking ends */\n  onEnd?: () => void;\n  /** Called for each chunk that is masked */\n  onMask?: (chunk: string) => void;\n}\n\n/**\n * Transforms a stream by masking content between XML tags.\n * @param stream Input stream to transform\n * @param tag Tag name to mask between (e.g. for <foo>...</foo>, use 'foo')\n * @param options Optional configuration for masking behavior\n */\nexport async function* maskStreamTags(\n  stream: AsyncIterable<string>,\n  tag: string,\n  options: TagMaskOptions = {},\n): AsyncIterable<string> {\n  const { onStart, onEnd, onMask } = options;\n  const openTag = `<${tag}>`;\n  const closeTag = `</${tag}>`;\n\n  let buffer = '';\n  let fullContent = '';\n  let isMasking = false;\n  let isBuffering = false;\n\n  // used for checking in chunks that include tags or partial tags + some other non-tag text\n  // eg: \"o <tag_name\" or \"name> w\", can trim before-start to get \"<tag_name\" or after-end to get \"name>\"\n  const trimOutsideDelimiter = (text: string, delimiter: string, trim: 'before-start' | 'after-end') => {\n    if (!text.includes(delimiter)) {\n      return text;\n    }\n\n    const parts = text.split(delimiter);\n\n    if (trim === `before-start`) {\n      return `${delimiter}${parts[1]}`;\n    }\n\n    return `${parts[0]}${delimiter}`;\n  };\n\n  // Helper to check if text starts with pattern (ignoring whitespace)\n  // When checking partial tags: startsWith(buffer, openTag) checks if buffer could be start of tag\n  // When checking full tags: startsWith(chunk, openTag) checks if chunk starts with full tag\n  const startsWith = (text: string, pattern: string) => {\n    // check start of opening tag\n    if (pattern.includes(openTag.substring(0, 3))) {\n      // our pattern for checking the start is always based on xml-like tags\n      // if the pattern looks like our opening tag and the pattern also includes\n      // some other chunked text before it, we just wanted to check the xml part of the pattern\n      pattern = trimOutsideDelimiter(pattern, `<`, `before-start`);\n    }\n\n    return text.trim().startsWith(pattern.trim());\n  };\n\n  for await (const chunk of stream) {\n    fullContent += chunk;\n\n    if (isBuffering) buffer += chunk;\n\n    const chunkHasTag = startsWith(chunk, openTag);\n    const bufferHasTag = !chunkHasTag && isBuffering && startsWith(openTag, buffer);\n\n    let toYieldBeforeMaskedStartTag = ``;\n    // Check if we should start masking chunks\n    if (!isMasking && (chunkHasTag || bufferHasTag)) {\n      isMasking = true;\n      isBuffering = false;\n\n      // check if the buffered text includes text before the start tag. ex \"o <tag_name\", \"o\" should be yielded and not masked\n      const taggedTextToMask = trimOutsideDelimiter(buffer, `<`, `before-start`);\n      if (taggedTextToMask !== buffer.trim()) {\n        toYieldBeforeMaskedStartTag = buffer.replace(taggedTextToMask, ``);\n      }\n\n      buffer = '';\n      onStart?.();\n    }\n\n    // Check if we should start buffering (looks like part of the opening tag but it's not the full <tag> yet eg <ta - could be <table> but we don't know yet)\n    if (!isMasking && !isBuffering && startsWith(openTag, chunk) && chunk.trim() !== '') {\n      isBuffering = true;\n      buffer += chunk;\n      continue;\n    }\n\n    // We're buffering, need to check again if our buffer has deviated from the opening <tag> eg <tag2>\n    if (isBuffering && buffer && !startsWith(openTag, buffer)) {\n      yield buffer;\n      buffer = '';\n      isBuffering = false;\n      continue;\n    }\n\n    // Check if we should stop masking chunks (since the content includes the closing </tag>)\n    if (isMasking && fullContent.includes(closeTag)) {\n      onMask?.(chunk);\n      onEnd?.();\n      isMasking = false;\n      const lastFullContent = fullContent;\n      fullContent = ``; // reset to handle streams with multiple full tags that have text inbetween\n\n      // check to see if we have a partial chunk outside the close tag. if we do we need to yield it so it isn't swallowed with the masked text\n      const textUntilEndTag = trimOutsideDelimiter(lastFullContent, closeTag, 'after-end');\n      if (textUntilEndTag !== lastFullContent) {\n        yield lastFullContent.replace(textUntilEndTag, ``);\n      }\n\n      continue;\n    }\n\n    // We're currently masking chunks inside a <tag>\n    if (isMasking) {\n      onMask?.(chunk);\n      // in the case that there was a chunk that included a tag to mask and some other text, ex \"o <tag_name\" we need to still yield the\n      // text before the tag (\"o \") so it's not swallowed with the masked text\n      if (toYieldBeforeMaskedStartTag) {\n        yield toYieldBeforeMaskedStartTag;\n      }\n      continue;\n    }\n\n    // default yield the chunk\n    yield chunk;\n  }\n}\n\n/**\n * Resolve serialized zod output - This function takes the string output ot the `jsonSchemaToZod` function\n * and instantiates the zod object correctly.\n *\n * @param schema - serialized zod object\n * @returns resolved zod object\n */\nexport function resolveSerializedZodOutput(schema: string): z.ZodType {\n  // Creates and immediately executes a new function that takes 'z' as a parameter\n  // The function body is a string that returns the serialized zod schema\n  // When executed with the 'z' parameter, it reconstructs the zod schema in the current context\n  return Function('z', `\"use strict\";return (${schema});`)(z);\n}\n\nexport interface ToolOptions {\n  name: string;\n  runId?: string;\n  threadId?: string;\n  resourceId?: string;\n  logger?: IMastraLogger;\n  description?: string;\n  mastra?: (Mastra & MastraPrimitives) | MastraPrimitives;\n  runtimeContext: RuntimeContext;\n  tracingContext: TracingContext;\n  memory?: MastraMemory;\n  agentName?: string;\n  model?: MastraLanguageModel;\n  writableStream?: WritableStream<ChunkType>;\n}\n\n/**\n * Checks if a value is a Zod type\n * @param value - The value to check\n * @returns True if the value is a Zod type, false otherwise\n */\nexport function isZodType(value: unknown): value is z.ZodType {\n  // Check if it's a Zod schema by looking for common Zod properties and methods\n  return (\n    typeof value === 'object' &&\n    value !== null &&\n    '_def' in value &&\n    'parse' in value &&\n    typeof (value as any).parse === 'function' &&\n    'safeParse' in value &&\n    typeof (value as any).safeParse === 'function'\n  );\n}\n\n// Helper function to create a deterministic hash\nfunction createDeterministicId(input: string): string {\n  return createHash('sha256').update(input).digest('hex').slice(0, 8); // Take first 8 characters for a shorter but still unique ID\n}\n\n/**\n * Sets the properties for a Vercel Tool, including an ID and inputSchema\n * @param tool - The tool to set the properties for\n * @returns The tool with the properties set\n */\nfunction setVercelToolProperties(tool: VercelTool) {\n  const inputSchema = convertVercelToolParameters(tool);\n  const toolId = !('id' in tool)\n    ? tool.description\n      ? `tool-${createDeterministicId(tool.description)}`\n      : `tool-${Math.random().toString(36).substring(2, 9)}`\n    : tool.id;\n  return {\n    ...tool,\n    id: toolId,\n    inputSchema,\n  };\n}\n\n/**\n * Ensures a tool has an ID and inputSchema by generating one if not present\n * @param tool - The tool to ensure has an ID and inputSchema\n * @returns The tool with an ID and inputSchema\n */\nexport function ensureToolProperties(tools: ToolsInput): ToolsInput {\n  const toolsWithProperties = Object.keys(tools).reduce<ToolsInput>((acc, key) => {\n    const tool = tools?.[key];\n    if (tool) {\n      if (isVercelTool(tool)) {\n        acc[key] = setVercelToolProperties(tool) as VercelTool;\n      } else {\n        acc[key] = tool;\n      }\n    }\n    return acc;\n  }, {});\n\n  return toolsWithProperties;\n}\n\nfunction convertVercelToolParameters(tool: VercelTool): z.ZodType {\n  // If the tool is a Vercel Tool, check if the parameters are already a zod object\n  // If not, convert the parameters to a zod object using jsonSchemaToZod\n  const schema = tool.parameters ?? z.object({});\n  return isZodType(schema) ? schema : resolveSerializedZodOutput(jsonSchemaToZod(schema));\n}\n\n/**\n * Converts a Vercel Tool or Mastra Tool into a CoreTool format\n * @param originalTool - The tool to convert (either VercelTool or ToolAction)\n * @param options - Tool options including Mastra-specific settings\n * @param logType - Type of tool to log (tool or toolset)\n * @returns A CoreTool that can be used by the system\n */\nexport function makeCoreTool(\n  originalTool: ToolToConvert,\n  options: ToolOptions,\n  logType?: 'tool' | 'toolset' | 'client-tool',\n): CoreTool {\n  return new CoreToolBuilder({ originalTool, options, logType }).build();\n}\n\nexport function makeCoreToolV5(\n  originalTool: ToolToConvert,\n  options: ToolOptions,\n  logType?: 'tool' | 'toolset' | 'client-tool',\n): VercelToolV5 {\n  return new CoreToolBuilder({ originalTool, options, logType }).buildV5();\n}\n\n/**\n * Creates a proxy for a Mastra instance to handle deprecated properties\n * @param mastra - The Mastra instance to proxy\n * @param logger - The logger to use for warnings\n * @returns A proxy for the Mastra instance\n */\nexport function createMastraProxy({ mastra, logger }: { mastra: Mastra; logger: IMastraLogger }) {\n  return new Proxy(mastra, {\n    get(target, prop) {\n      const hasProp = Reflect.has(target, prop);\n\n      if (hasProp) {\n        const value = Reflect.get(target, prop);\n        const isFunction = typeof value === 'function';\n        if (isFunction) {\n          return value.bind(target);\n        }\n        return value;\n      }\n\n      if (prop === 'logger') {\n        logger.warn(`Please use 'getLogger' instead, logger is deprecated`);\n        return Reflect.apply(target.getLogger, target, []);\n      }\n\n      if (prop === 'telemetry') {\n        logger.warn(`Please use 'getTelemetry' instead, telemetry is deprecated`);\n        return Reflect.apply(target.getTelemetry, target, []);\n      }\n\n      if (prop === 'storage') {\n        logger.warn(`Please use 'getStorage' instead, storage is deprecated`);\n        return Reflect.get(target, 'storage');\n      }\n\n      if (prop === 'agents') {\n        logger.warn(`Please use 'getAgents' instead, agents is deprecated`);\n        return Reflect.apply(target.getAgents, target, []);\n      }\n\n      if (prop === 'tts') {\n        logger.warn(`Please use 'getTTS' instead, tts is deprecated`);\n        return Reflect.apply(target.getTTS, target, []);\n      }\n\n      if (prop === 'vectors') {\n        logger.warn(`Please use 'getVectors' instead, vectors is deprecated`);\n        return Reflect.apply(target.getVectors, target, []);\n      }\n\n      if (prop === 'memory') {\n        logger.warn(`Please use 'getMemory' instead, memory is deprecated`);\n        return Reflect.get(target, 'memory');\n      }\n\n      return Reflect.get(target, prop);\n    },\n  });\n}\n\nexport function checkEvalStorageFields(traceObject: any, logger?: IMastraLogger) {\n  const missingFields = [];\n  if (!traceObject.input) missingFields.push('input');\n  if (!traceObject.output) missingFields.push('output');\n  if (!traceObject.agentName) missingFields.push('agent_name');\n  if (!traceObject.metricName) missingFields.push('metric_name');\n  if (!traceObject.instructions) missingFields.push('instructions');\n  if (!traceObject.globalRunId) missingFields.push('global_run_id');\n  if (!traceObject.runId) missingFields.push('run_id');\n\n  if (missingFields.length > 0) {\n    if (logger) {\n      logger.warn('Skipping evaluation storage due to missing required fields', {\n        missingFields,\n        runId: traceObject.runId,\n        agentName: traceObject.agentName,\n      });\n    } else {\n      console.warn('Skipping evaluation storage due to missing required fields', {\n        missingFields,\n        runId: traceObject.runId,\n        agentName: traceObject.agentName,\n      });\n    }\n    return false;\n  }\n\n  return true;\n}\n\n// lifted from https://github.com/vercel/ai/blob/main/packages/ai/core/prompt/detect-prompt-type.ts#L27\nfunction detectSingleMessageCharacteristics(\n  message: any,\n): 'has-ui-specific-parts' | 'has-core-specific-parts' | 'message' | 'other' {\n  if (\n    typeof message === 'object' &&\n    message !== null &&\n    (message.role === 'function' || // UI-only role\n      message.role === 'data' || // UI-only role\n      'toolInvocations' in message || // UI-specific field\n      'parts' in message || // UI-specific field\n      'experimental_attachments' in message)\n  ) {\n    return 'has-ui-specific-parts';\n  } else if (\n    typeof message === 'object' &&\n    message !== null &&\n    'content' in message &&\n    (Array.isArray(message.content) || // Core messages can have array content\n      'experimental_providerMetadata' in message ||\n      'providerOptions' in message)\n  ) {\n    return 'has-core-specific-parts';\n  } else if (\n    typeof message === 'object' &&\n    message !== null &&\n    'role' in message &&\n    'content' in message &&\n    typeof message.content === 'string' &&\n    ['system', 'user', 'assistant', 'tool'].includes(message.role)\n  ) {\n    return 'message';\n  } else {\n    return 'other';\n  }\n}\n\nexport function isUiMessage(message: CoreMessage | AiMessageType): message is AiMessageType {\n  return detectSingleMessageCharacteristics(message) === `has-ui-specific-parts`;\n}\nexport function isCoreMessage(message: CoreMessage | AiMessageType): message is CoreMessage {\n  return [`has-core-specific-parts`, `message`].includes(detectSingleMessageCharacteristics(message));\n}\n\n/** Represents a validated SQL identifier (e.g., table or column name). */\ntype SqlIdentifier = string & { __brand: 'SqlIdentifier' };\n/** Represents a validated dot-separated SQL field key. */\ntype FieldKey = string & { __brand: 'FieldKey' };\n\nconst SQL_IDENTIFIER_PATTERN = /^[a-zA-Z_][a-zA-Z0-9_]*$/;\n\n/**\n * Parses and returns a valid SQL identifier (such as a table or column name).\n * The identifier must:\n *   - Start with a letter (a-z, A-Z) or underscore (_)\n *   - Contain only letters, numbers, or underscores\n *   - Be at most 63 characters long\n *\n * @param name - The identifier string to parse.\n * @param kind - Optional label for error messages (e.g., 'table name').\n * @returns The validated identifier as a branded type.\n * @throws {Error} If the identifier does not conform to SQL naming rules.\n *\n * @example\n * const id = parseSqlIdentifier('my_table'); // Ok\n * parseSqlIdentifier('123table'); // Throws error\n */\nexport function parseSqlIdentifier(name: string, kind = 'identifier'): SqlIdentifier {\n  if (!SQL_IDENTIFIER_PATTERN.test(name) || name.length > 63) {\n    throw new Error(\n      `Invalid ${kind}: ${name}. Must start with a letter or underscore, contain only letters, numbers, or underscores, and be at most 63 characters long.`,\n    );\n  }\n  return name as SqlIdentifier;\n}\n\n/**\n * Parses and returns a valid dot-separated SQL field key (e.g., 'user.profile.name').\n * Each segment must:\n *   - Start with a letter (a-z, A-Z) or underscore (_)\n *   - Contain only letters, numbers, or underscores\n *   - Be at most 63 characters long\n *\n * @param key - The dot-separated field key string to parse.\n * @returns The validated field key as a branded type.\n * @throws {Error} If any segment of the key is invalid.\n *\n * @example\n * const key = parseFieldKey('user_profile.name'); // Ok\n * parseFieldKey('user..name'); // Throws error\n * parseFieldKey('user.123name'); // Throws error\n */\nexport function parseFieldKey(key: string): FieldKey {\n  if (!key) throw new Error('Field key cannot be empty');\n  const segments = key.split('.');\n  for (const segment of segments) {\n    if (!SQL_IDENTIFIER_PATTERN.test(segment) || segment.length > 63) {\n      throw new Error(`Invalid field key segment: ${segment} in ${key}`);\n    }\n  }\n  return key as FieldKey;\n}\n\n/**\n * Performs a fetch request with automatic retries using exponential backoff\n * @param url The URL to fetch from\n * @param options Standard fetch options\n * @param maxRetries Maximum number of retry attempts\n * @param validateResponse Optional function to validate the response beyond HTTP status\n * @returns The fetch Response if successful\n */\nexport async function fetchWithRetry(\n  url: string,\n  options: RequestInit = {},\n  maxRetries: number = 3,\n): Promise<Response> {\n  let retryCount = 0;\n  let lastError: Error | null = null;\n\n  while (retryCount < maxRetries) {\n    try {\n      const response = await fetch(url, options);\n\n      if (!response.ok) {\n        throw new Error(`Request failed with status: ${response.status} ${response.statusText}`);\n      }\n\n      return response;\n    } catch (error) {\n      lastError = error instanceof Error ? error : new Error(String(error));\n      retryCount++;\n\n      if (retryCount >= maxRetries) {\n        break;\n      }\n\n      const delay = Math.min(1000 * Math.pow(2, retryCount) * 1000, 10000);\n      await new Promise(resolve => setTimeout(resolve, delay));\n    }\n  }\n\n  throw lastError || new Error('Request failed after multiple retry attempts');\n}\n"]}
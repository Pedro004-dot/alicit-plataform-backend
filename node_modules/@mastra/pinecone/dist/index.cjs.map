{"version":3,"sources":["../src/vector/filter.ts","../src/vector/index.ts","../src/vector/prompt.ts"],"names":["BaseFilterTranslator","MastraVector","Pinecone","MastraError","ErrorDomain","ErrorCategory","error"],"mappings":"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","file":"index.cjs","sourcesContent":["import { BaseFilterTranslator } from '@mastra/core/vector/filter';\nimport type {\n  VectorFilter,\n  OperatorSupport,\n  OperatorValueMap,\n  LogicalOperatorValueMap,\n  BlacklistedRootOperators,\n  QueryOperator,\n  FilterValue,\n  OperatorCondition,\n} from '@mastra/core/vector/filter';\n\ntype InitialOperatorValueMap = Omit<OperatorValueMap, '$regex' | '$options' | '$elemMatch' | '$all'> & {\n  $contains: string;\n  $gt: number | Date;\n  $gte: number | Date;\n  $lt: number | Date;\n  $lte: number | Date;\n};\n\ntype PineconeOperatorValueMap = InitialOperatorValueMap & {\n  $all: OperatorCondition<keyof InitialOperatorValueMap, InitialOperatorValueMap>[] | FilterValue[];\n};\ntype PineconeLogicalOperatorValueMap = Omit<LogicalOperatorValueMap, '$not' | '$nor'>;\n\ntype PineconeBlacklisted = BlacklistedRootOperators | '$not' | '$nor';\n\nexport type PineconeVectorFilter = VectorFilter<\n  keyof PineconeOperatorValueMap,\n  PineconeOperatorValueMap,\n  PineconeLogicalOperatorValueMap,\n  PineconeBlacklisted\n>;\n\nexport class PineconeFilterTranslator extends BaseFilterTranslator<PineconeVectorFilter> {\n  protected override getSupportedOperators(): OperatorSupport {\n    return {\n      ...BaseFilterTranslator.DEFAULT_OPERATORS,\n      logical: ['$and', '$or'],\n      array: ['$in', '$all', '$nin'],\n      element: ['$exists'],\n      regex: [],\n      custom: [],\n    };\n  }\n\n  translate(filter?: PineconeVectorFilter): PineconeVectorFilter {\n    if (this.isEmpty(filter)) return filter;\n    this.validateFilter(filter);\n    return this.translateNode(filter);\n  }\n\n  private translateNode(node: PineconeVectorFilter, currentPath: string = ''): any {\n    if (this.isRegex(node)) {\n      throw new Error('Regex is not supported in Pinecone');\n    }\n    if (this.isPrimitive(node)) return this.normalizeComparisonValue(node);\n    if (Array.isArray(node)) return { $in: this.normalizeArrayValues(node) };\n\n    const entries = Object.entries(node as Record<string, any>);\n    const firstEntry = entries[0];\n\n    // Handle single operator case\n    if (entries.length === 1 && firstEntry && this.isOperator(firstEntry[0])) {\n      const [operator, value] = firstEntry;\n      const translated = this.translateOperator(operator, value, currentPath);\n      return this.isLogicalOperator(operator) ? { [operator]: translated } : translated;\n    }\n\n    // Process each entry\n    const result: Record<string, any> = {};\n\n    for (const [key, value] of entries) {\n      const newPath = currentPath ? `${currentPath}.${key}` : key;\n\n      if (this.isOperator(key)) {\n        result[key] = this.translateOperator(key, value, currentPath);\n        continue;\n      }\n\n      if (typeof value === 'object' && value !== null && !Array.isArray(value)) {\n        // Handle nested $all\n        if (Object.keys(value).length === 1 && '$all' in value) {\n          const translated = this.translateNode(value, key);\n          if (translated.$and) {\n            return translated;\n          }\n        }\n\n        // Check if the nested object contains operators\n        if (Object.keys(value).length === 0) {\n          result[newPath] = this.translateNode(value);\n        } else {\n          const hasOperators = Object.keys(value).some(k => this.isOperator(k));\n          if (hasOperators) {\n            // For objects with operators, normalize each operator value\n            const normalizedValue: Record<string, any> = {};\n            for (const [op, opValue] of Object.entries(value)) {\n              normalizedValue[op] = this.isOperator(op) ? this.translateOperator(op, opValue) : opValue;\n            }\n            result[newPath] = normalizedValue;\n          } else {\n            // For objects without operators, flatten them\n            Object.assign(result, this.translateNode(value, newPath));\n          }\n        }\n      } else {\n        result[newPath] = this.translateNode(value);\n      }\n    }\n\n    return result;\n  }\n\n  private translateOperator(operator: QueryOperator, value: any, currentPath: string = ''): any {\n    // Handle $all specially\n    if (operator === '$all') {\n      if (!Array.isArray(value) || value.length === 0) {\n        throw new Error('A non-empty array is required for the $all operator');\n      }\n\n      return this.simulateAllOperator(currentPath, value);\n    }\n\n    // Handle logical operators\n    if (this.isLogicalOperator(operator)) {\n      return Array.isArray(value) ? value.map(item => this.translateNode(item)) : this.translateNode(value);\n    }\n\n    // Handle comparison and element operators\n    return this.normalizeComparisonValue(value);\n  }\n}\n","import { MastraError, ErrorDomain, ErrorCategory } from '@mastra/core/error';\nimport { MastraVector } from '@mastra/core/vector';\nimport type {\n  QueryResult,\n  IndexStats,\n  CreateIndexParams,\n  UpsertVectorParams,\n  QueryVectorParams,\n  DescribeIndexParams,\n  DeleteIndexParams,\n  DeleteVectorParams,\n  UpdateVectorParams,\n} from '@mastra/core/vector';\nimport { Pinecone } from '@pinecone-database/pinecone';\nimport type {\n  IndexStatsDescription,\n  QueryOptions,\n  RecordSparseValues,\n  UpdateOptions,\n} from '@pinecone-database/pinecone';\n\nimport { PineconeFilterTranslator } from './filter';\nimport type { PineconeVectorFilter } from './filter';\n\ninterface PineconeIndexStats extends IndexStats {\n  namespaces?: IndexStatsDescription['namespaces'];\n}\n\ninterface PineconeQueryVectorParams extends QueryVectorParams<PineconeVectorFilter> {\n  namespace?: string;\n  sparseVector?: RecordSparseValues;\n}\n\ninterface PineconeUpsertVectorParams extends UpsertVectorParams {\n  namespace?: string;\n  sparseVectors?: RecordSparseValues[];\n}\n\ninterface PineconeUpdateVectorParams extends UpdateVectorParams {\n  namespace?: string;\n}\n\ninterface PineconeDeleteVectorParams extends DeleteVectorParams {\n  namespace?: string;\n}\n\nexport class PineconeVector extends MastraVector<PineconeVectorFilter> {\n  private client: Pinecone;\n\n  /**\n   * Creates a new PineconeVector client.\n   * @param apiKey - The API key for Pinecone.\n   * @param environment - The environment for Pinecone.\n   */\n  constructor({ apiKey, environment }: { apiKey: string; environment?: string }) {\n    super();\n    const opts: { apiKey: string; controllerHostUrl?: string } = { apiKey };\n    if (environment) {\n      opts['controllerHostUrl'] = environment;\n    }\n    const baseClient = new Pinecone(opts);\n    const telemetry = this.__getTelemetry();\n    this.client =\n      telemetry?.traceClass(baseClient, {\n        spanNamePrefix: 'pinecone-vector',\n        attributes: {\n          'vector.type': 'pinecone',\n        },\n      }) ?? baseClient;\n  }\n\n  get indexSeparator(): string {\n    return '-';\n  }\n\n  async createIndex({ indexName, dimension, metric = 'cosine' }: CreateIndexParams): Promise<void> {\n    try {\n      if (!Number.isInteger(dimension) || dimension <= 0) {\n        throw new Error('Dimension must be a positive integer');\n      }\n      if (metric && !['cosine', 'euclidean', 'dotproduct'].includes(metric)) {\n        throw new Error('Metric must be one of: cosine, euclidean, dotproduct');\n      }\n    } catch (validationError) {\n      throw new MastraError(\n        {\n          id: 'STORAGE_PINECONE_VECTOR_CREATE_INDEX_INVALID_ARGS',\n          domain: ErrorDomain.STORAGE,\n          category: ErrorCategory.USER,\n          details: { indexName, dimension, metric },\n        },\n        validationError,\n      );\n    }\n\n    try {\n      await this.client.createIndex({\n        name: indexName,\n        dimension: dimension,\n        metric: metric,\n        spec: {\n          serverless: {\n            cloud: 'aws',\n            region: 'us-east-1',\n          },\n        },\n      });\n    } catch (error: any) {\n      // Check for 'already exists' error\n      const message = error?.errors?.[0]?.message || error?.message;\n      if (\n        error.status === 409 ||\n        (typeof message === 'string' &&\n          (message.toLowerCase().includes('already exists') || message.toLowerCase().includes('duplicate')))\n      ) {\n        // Fetch index info and check dimensions\n        await this.validateExistingIndex(indexName, dimension, metric);\n        return;\n      }\n      // For any other errors, wrap in MastraError\n      throw new MastraError(\n        {\n          id: 'STORAGE_PINECONE_VECTOR_CREATE_INDEX_FAILED',\n          domain: ErrorDomain.STORAGE,\n          category: ErrorCategory.THIRD_PARTY,\n          details: { indexName, dimension, metric },\n        },\n        error,\n      );\n    }\n  }\n\n  async upsert({\n    indexName,\n    vectors,\n    metadata,\n    ids,\n    namespace,\n    sparseVectors,\n  }: PineconeUpsertVectorParams): Promise<string[]> {\n    const index = this.client.Index(indexName).namespace(namespace || '');\n\n    // Generate IDs if not provided\n    const vectorIds = ids || vectors.map(() => crypto.randomUUID());\n\n    const records = vectors.map((vector, i) => ({\n      id: vectorIds[i]!,\n      values: vector,\n      ...(sparseVectors?.[i] && { sparseValues: sparseVectors?.[i] }),\n      metadata: metadata?.[i] || {},\n    }));\n\n    // Pinecone has a limit of 100 vectors per upsert request\n    const batchSize = 100;\n    try {\n      for (let i = 0; i < records.length; i += batchSize) {\n        const batch = records.slice(i, i + batchSize);\n        await index.upsert(batch);\n      }\n\n      return vectorIds;\n    } catch (error) {\n      throw new MastraError(\n        {\n          id: 'STORAGE_PINECONE_VECTOR_UPSERT_FAILED',\n          domain: ErrorDomain.STORAGE,\n          category: ErrorCategory.THIRD_PARTY,\n          details: { indexName, vectorCount: vectors.length },\n        },\n        error,\n      );\n    }\n  }\n\n  transformFilter(filter?: PineconeVectorFilter) {\n    const translator = new PineconeFilterTranslator();\n    return translator.translate(filter);\n  }\n\n  async query({\n    indexName,\n    queryVector,\n    topK = 10,\n    filter,\n    includeVector = false,\n    namespace,\n    sparseVector,\n  }: PineconeQueryVectorParams): Promise<QueryResult[]> {\n    const index = this.client.Index(indexName).namespace(namespace || '');\n\n    const translatedFilter = this.transformFilter(filter) ?? undefined;\n\n    const queryParams: QueryOptions = {\n      vector: queryVector,\n      topK,\n      includeMetadata: true,\n      includeValues: includeVector,\n      filter: translatedFilter,\n    };\n\n    // If sparse vector is provided, use hybrid search\n    if (sparseVector) {\n      queryParams.sparseVector = sparseVector;\n    }\n\n    try {\n      const results = await index.query(queryParams);\n\n      return results.matches.map(match => ({\n        id: match.id,\n        score: match.score || 0,\n        metadata: match.metadata as Record<string, any>,\n        ...(includeVector && { vector: match.values || [] }),\n      }));\n    } catch (error) {\n      throw new MastraError(\n        {\n          id: 'STORAGE_PINECONE_VECTOR_QUERY_FAILED',\n          domain: ErrorDomain.STORAGE,\n          category: ErrorCategory.THIRD_PARTY,\n          details: { indexName, topK },\n        },\n        error,\n      );\n    }\n  }\n\n  async listIndexes(): Promise<string[]> {\n    try {\n      const indexesResult = await this.client.listIndexes();\n      return indexesResult?.indexes?.map(index => index.name) || [];\n    } catch (error) {\n      throw new MastraError(\n        {\n          id: 'STORAGE_PINECONE_VECTOR_LIST_INDEXES_FAILED',\n          domain: ErrorDomain.STORAGE,\n          category: ErrorCategory.THIRD_PARTY,\n        },\n        error,\n      );\n    }\n  }\n\n  /**\n   * Retrieves statistics about a vector index.\n   *\n   * @param {string} indexName - The name of the index to describe\n   * @returns A promise that resolves to the index statistics including dimension, count and metric\n   */\n  async describeIndex({ indexName }: DescribeIndexParams): Promise<PineconeIndexStats> {\n    try {\n      const index = this.client.Index(indexName);\n      const stats = await index.describeIndexStats();\n      const description = await this.client.describeIndex(indexName);\n\n      return {\n        dimension: description.dimension,\n        count: stats.totalRecordCount || 0,\n        metric: description.metric as 'cosine' | 'euclidean' | 'dotproduct',\n        namespaces: stats.namespaces,\n      };\n    } catch (error) {\n      throw new MastraError(\n        {\n          id: 'STORAGE_PINECONE_VECTOR_DESCRIBE_INDEX_FAILED',\n          domain: ErrorDomain.STORAGE,\n          category: ErrorCategory.THIRD_PARTY,\n          details: { indexName },\n        },\n        error,\n      );\n    }\n  }\n\n  async deleteIndex({ indexName }: DeleteIndexParams): Promise<void> {\n    try {\n      await this.client.deleteIndex(indexName);\n    } catch (error) {\n      throw new MastraError(\n        {\n          id: 'STORAGE_PINECONE_VECTOR_DELETE_INDEX_FAILED',\n          domain: ErrorDomain.STORAGE,\n          category: ErrorCategory.THIRD_PARTY,\n          details: { indexName },\n        },\n        error,\n      );\n    }\n  }\n\n  /**\n   * Updates a vector by its ID with the provided vector and/or metadata.\n   * @param indexName - The name of the index containing the vector.\n   * @param id - The ID of the vector to update.\n   * @param update - An object containing the vector and/or metadata to update.\n   * @param update.vector - An optional array of numbers representing the new vector.\n   * @param update.metadata - An optional record containing the new metadata.\n   * @param namespace - The namespace of the index (optional).\n   * @returns A promise that resolves when the update is complete.\n   * @throws Will throw an error if no updates are provided or if the update operation fails.\n   */\n  async updateVector({ indexName, id, update, namespace }: PineconeUpdateVectorParams): Promise<void> {\n    if (!update.vector && !update.metadata) {\n      throw new MastraError({\n        id: 'STORAGE_PINECONE_VECTOR_UPDATE_VECTOR_INVALID_ARGS',\n        domain: ErrorDomain.STORAGE,\n        category: ErrorCategory.USER,\n        text: 'No updates provided',\n        details: { indexName, id },\n      });\n    }\n\n    try {\n      const index = this.client.Index(indexName).namespace(namespace || '');\n\n      const updateObj: UpdateOptions = { id };\n\n      if (update.vector) {\n        updateObj.values = update.vector;\n      }\n\n      if (update.metadata) {\n        updateObj.metadata = update.metadata;\n      }\n\n      await index.update(updateObj);\n    } catch (error) {\n      throw new MastraError(\n        {\n          id: 'STORAGE_PINECONE_VECTOR_UPDATE_VECTOR_FAILED',\n          domain: ErrorDomain.STORAGE,\n          category: ErrorCategory.THIRD_PARTY,\n          details: { indexName, id },\n        },\n        error,\n      );\n    }\n  }\n\n  /**\n   * Deletes a vector by its ID.\n   * @param indexName - The name of the index containing the vector.\n   * @param id - The ID of the vector to delete.\n   * @param namespace - The namespace of the index (optional).\n   * @returns A promise that resolves when the deletion is complete.\n   * @throws Will throw an error if the deletion operation fails.\n   */\n  async deleteVector({ indexName, id, namespace }: PineconeDeleteVectorParams): Promise<void> {\n    try {\n      const index = this.client.Index(indexName).namespace(namespace || '');\n      await index.deleteOne(id);\n    } catch (error) {\n      throw new MastraError(\n        {\n          id: 'STORAGE_PINECONE_VECTOR_DELETE_VECTOR_FAILED',\n          domain: ErrorDomain.STORAGE,\n          category: ErrorCategory.THIRD_PARTY,\n          details: { indexName, id },\n        },\n        error,\n      );\n    }\n  }\n}\n","/**\n * Vector store specific prompt that details supported operators and examples.\n * This prompt helps users construct valid filters for Pinecone Vector.\n */\nexport const PINECONE_PROMPT = `When querying Pinecone, you can ONLY use the operators listed below. Any other operators will be rejected.\nImportant: Don't explain how to construct the filter - use the specified operators and fields to search the content and return relevant results.\nIf a user tries to give an explicit operator that is not supported, reject the filter entirely and let them know that the operator is not supported.\n\nBasic Comparison Operators:\n- $eq: Exact match (default when using field: value)\n  Example: { \"category\": \"electronics\" }\n- $ne: Not equal\n  Example: { \"category\": { \"$ne\": \"electronics\" } }\n- $gt: Greater than\n  Example: { \"price\": { \"$gt\": 100 } }\n- $gte: Greater than or equal\n  Example: { \"price\": { \"$gte\": 100 } }\n- $lt: Less than\n  Example: { \"price\": { \"$lt\": 100 } }\n- $lte: Less than or equal\n  Example: { \"price\": { \"$lte\": 100 } }\n\nArray Operators:\n- $in: Match any value in array\n  Example: { \"category\": { \"$in\": [\"electronics\", \"books\"] } }\n- $nin: Does not match any value in array\n  Example: { \"category\": { \"$nin\": [\"electronics\", \"books\"] } }\n- $all: Match all values in array\n  Example: { \"tags\": { \"$all\": [\"premium\", \"sale\"] } }\n\nLogical Operators:\n- $and: Logical AND (can be implicit or explicit)\n  Implicit Example: { \"price\": { \"$gt\": 100 }, \"category\": \"electronics\" }\n  Explicit Example: { \"$and\": [{ \"price\": { \"$gt\": 100 } }, { \"category\": \"electronics\" }] }\n- $or: Logical OR\n  Example: { \"$or\": [{ \"price\": { \"$lt\": 50 } }, { \"category\": \"books\" }] }\n\nElement Operators:\n- $exists: Check if field exists\n  Example: { \"rating\": { \"$exists\": true } }\n\nRestrictions:\n- Regex patterns are not supported\n- Only $and and $or logical operators are supported at the top level\n- Empty arrays in $in/$nin will return no results\n- A non-empty array is required for $all operator\n- Nested fields are supported using dot notation\n- Multiple conditions on the same field are supported with both implicit and explicit $and\n- At least one key-value pair is required in filter object\n- Empty objects and undefined values are treated as no filter\n- Invalid types in comparison operators will throw errors\n- All non-logical operators must be used within a field condition\n  Valid: { \"field\": { \"$gt\": 100 } }\n  Valid: { \"$and\": [...] }\n  Invalid: { \"$gt\": 100 }\n- Logical operators must contain field conditions, not direct operators\n  Valid: { \"$and\": [{ \"field\": { \"$gt\": 100 } }] }\n  Invalid: { \"$and\": [{ \"$gt\": 100 }] }\n- Logical operators ($and, $or):\n  - Can only be used at top level or nested within other logical operators\n  - Can not be used on a field level, or be nested inside a field\n  - Can not be used inside an operator\n  - Valid: { \"$and\": [{ \"field\": { \"$gt\": 100 } }] }\n  - Valid: { \"$or\": [{ \"$and\": [{ \"field\": { \"$gt\": 100 } }] }] }\n  - Invalid: { \"field\": { \"$and\": [{ \"$gt\": 100 }] } }\n  - Invalid: { \"field\": { \"$or\": [{ \"$gt\": 100 }] } }\n  - Invalid: { \"field\": { \"$gt\": { \"$and\": [{...}] } } }\n\nExample Complex Query:\n{\n  \"$and\": [\n    { \"category\": { \"$in\": [\"electronics\", \"computers\"] } },\n    { \"price\": { \"$gte\": 100, \"$lte\": 1000 } },\n    { \"tags\": { \"$all\": [\"premium\", \"sale\"] } },\n    { \"rating\": { \"$exists\": true, \"$gt\": 4 } },\n    { \"$or\": [\n      { \"stock\": { \"$gt\": 0 } },\n      { \"preorder\": true }\n    ]}\n  ]\n}`;\n"]}
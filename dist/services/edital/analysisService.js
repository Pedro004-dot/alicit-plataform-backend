"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.EditalAnalysisService = void 0;
const RAGService_1 = require("./RAGService");
const hooks_1 = require("./hooks");
// import { mastra } from "../../mastra"; // Temporariamente removido para compatibilidade Vercel serverless
const sequential_1 = require("../../mastra/agents/sequential");
const empresaRepository_1 = __importDefault(require("../../repositories/empresaRepository"));
const relatorioStorageService_1 = require("./relatorioStorageService");
class EditalAnalysisService {
    constructor() {
        this.ragService = new RAGService_1.EditalRAGService();
        this.relatoriosService = new relatorioStorageService_1.RelatorioStorageService();
    }
    async initialize() {
        await this.ragService.initialize();
    }
    /**
     * Busca e formata contexto da empresa para enriquecer an√°lise dos agentes
     */
    async getEmpresaContext(empresaCNPJ) {
        if (!empresaCNPJ) {
            console.log('‚ö†Ô∏è CNPJ n√£o fornecido - continuando sem contexto espec√≠fico');
            return null;
        }
        try {
            console.log(`üîç Buscando contexto da empresa por CNPJ: ${empresaCNPJ}`);
            const empresa = await empresaRepository_1.default.getEmpresaByCnpj(empresaCNPJ);
            if (!empresa) {
                console.log(`‚ùå Empresa n√£o encontrada: ${empresaCNPJ}`);
                return null;
            }
            const context = {
                nome: empresa.nome || 'N√£o informado',
                cnpj: empresa.cnpj || empresaCNPJ,
                porte: empresa.porte || "M√©dio",
                segmento: empresa.segmento || 'N√£o informado',
                produtos: empresa.empresa_produtos?.map((p) => p.produto) || [],
                servicos: empresa.empresa_servicos?.map((s) => s.servico) || [],
                localizacao: empresa.cidade || 'N√£o informado',
                capacidadeOperacional: empresa.capacidade_operacional || 'N√£o informado',
                documentosDisponiveis: {}
            };
            console.log(`‚úÖ Contexto da empresa obtido: ${context.nome} (${context.porte})`);
            console.log(`üì¶ Produtos: ${context.produtos.length} | Servi√ßos: ${context.servicos.length}`);
            return context;
        }
        catch (error) {
            console.error(`‚ùå Erro ao buscar contexto da empresa ${empresaCNPJ}:`, error);
            return null;
        }
    }
    async analyzeEdital(request) {
        try {
            console.log('üöÄ IN√çCIO - analyzeEdital');
            console.log('üöÄ Request:', JSON.stringify(request));
            // Garantir que RAGService est√° inicializado com Pinecone
            await this.ragService.initialize();
            console.log('üîÑ Processando RAG...');
            const ragResult = await this.ragService.processEdital(request);
            console.log('‚úÖ RAG processado com sucesso!');
            console.log('‚úÖ RAG resultado:', JSON.stringify({
                licitacaoId: ragResult.licitacaoId,
                processed: ragResult.processed,
                documentsCount: ragResult.documentsCount,
                chunksCount: ragResult.chunksCount
            }));
            console.log('‚úÖ RAG processado, buscando contexto da empresa...');
            // Buscar contexto da empresa para enriquecer an√°lise dos agentes
            const empresaContext = await this.getEmpresaContext(request.empresaCNPJ);
            if (empresaContext) {
                console.log('üìä DADOS DA EMPRESA COMPLETOS:');
                console.log('  Nome:', empresaContext.nome || 'N/A');
                console.log('  CNPJ:', empresaContext.cnpj || 'N/A');
                console.log('  Porte:', empresaContext.porte || 'N/A');
                console.log('  Segmento:', empresaContext.segmento || 'N/A');
                console.log('  Produtos:', empresaContext.produtos?.length || 0, 'items:', empresaContext.produtos || []);
                console.log('  Servi√ßos:', empresaContext.servicos?.length || 0, 'items:', empresaContext.servicos || []);
                console.log('  Localiza√ß√£o:', empresaContext.localizacao || 'N/A');
                console.log('  Capacidade Operacional:', empresaContext.capacidadeOperacional || 'N/A');
                console.log('  Documentos Dispon√≠veis:', empresaContext.documentosDisponiveis ? Object.keys(empresaContext.documentosDisponiveis).length + ' tipos' : 'Nenhum');
            }
            else {
                console.log('‚ö†Ô∏è EMPRESA CONTEXT √â NULL - usando contexto padr√£o');
            }
            console.log('‚úÖ Contexto obtido, iniciando workflow...');
            let workflowResult;
            let workflowError = null;
            try {
                console.log('üîÑ Executando an√°lise sequencial com agentes individuais...');
                const threadId = `licitacao_${request.licitacaoId}`;
                const resourceId = request.empresaCNPJ || 'default-empresa';
                // Executar agente estrat√©gico
                console.log('üéØ Executando an√°lise de ader√™ncia estrat√©gica...');
                const strategicResult = await sequential_1.sequentialAgents.strategicFitAgent.generate(`Analise a ader√™ncia estrat√©gica da licita√ß√£o ${request.licitacaoId} com nossa empresa.`, { threadId, resourceId });
                const strategicScore = extractScoreFromText(strategicResult.text || "");
                console.log(`üìä Score estrat√©gico: ${strategicScore}/100`);
                let finalReport = `# AN√ÅLISE DE LICITA√á√ÉO - ${request.licitacaoId}

## RESUMO EXECUTIVO
- **Licita√ß√£o ID:** ${request.licitacaoId}
- **Data da An√°lise:** ${new Date().toLocaleString('pt-BR')}
- **Empresa:** ${empresaContext?.nome || 'Empresa n√£o identificada'}

## 1. AN√ÅLISE DE ADER√äNCIA ESTRAT√âGICA
${strategicResult.text || 'An√°lise n√£o dispon√≠vel'}

**Score Ader√™ncia:** ${strategicScore}/100
`;
                if (strategicScore >= 60) {
                    // Executar agente operacional
                    console.log('‚öôÔ∏è Executando an√°lise operacional...');
                    const operationalResult = await sequential_1.sequentialAgents.operationalAgent.generate(`Analise a capacidade operacional para executar a licita√ß√£o ${request.licitacaoId}.`, { threadId, resourceId });
                    const operationalScore = extractScoreFromText(operationalResult.text || "");
                    console.log(`üìä Score operacional: ${operationalScore}/100`);
                    finalReport += `

## 2. AN√ÅLISE OPERACIONAL
${operationalResult.text || 'An√°lise n√£o dispon√≠vel'}

**Score Operacional:** ${operationalScore}/100
`;
                    if (operationalScore >= 50) {
                        // Executar agente jur√≠dico
                        console.log('‚öñÔ∏è Executando an√°lise jur√≠dico-documental...');
                        const legalResult = await sequential_1.sequentialAgents.legalDocAgent.generate(`Analise os aspectos jur√≠dico-documentais da licita√ß√£o ${request.licitacaoId}.`, { threadId, resourceId });
                        const legalScore = extractScoreFromText(legalResult.text || "");
                        console.log(`üìä Score jur√≠dico: ${legalScore}/100`);
                        finalReport += `

## 3. AN√ÅLISE JUR√çDICO-DOCUMENTAL
${legalResult.text || 'An√°lise n√£o dispon√≠vel'}

**Score Jur√≠dico:** ${legalScore}/100
`;
                        if (legalScore >= 40) {
                            // Executar agente financeiro
                            console.log('üí∞ Executando an√°lise financeira...');
                            const financialResult = await sequential_1.sequentialAgents.financialAgent.generate(`Fa√ßa a an√°lise financeira consolidada da licita√ß√£o ${request.licitacaoId}.`, { threadId, resourceId });
                            const financialScore = extractScoreFromText(financialResult.text || "");
                            console.log(`üìä Score financeiro: ${financialScore}/100`);
                            finalReport += `

## 4. AN√ÅLISE FINANCEIRA
${financialResult.text || 'An√°lise n√£o dispon√≠vel'}

**Score Financeiro:** ${financialScore}/100

## S√çNTESE FINAL
**Scores Obtidos:**
- Ader√™ncia Estrat√©gica: ${strategicScore}/100 (30%)
- Capacidade Operacional: ${operationalScore}/100 (25%)
- Situa√ß√£o Jur√≠dica: ${legalScore}/100 (20%)
- Atratividade Financeira: ${financialScore}/100 (25%)

**Score Consolidado:** ${Math.round(strategicScore * 0.3 + operationalScore * 0.25 + legalScore * 0.2 + financialScore * 0.25)}/100

**RECOMENDA√á√ÉO:** ${Math.round(strategicScore * 0.3 + operationalScore * 0.25 + legalScore * 0.2 + financialScore * 0.25) >= 70 ? '‚úÖ PARTICIPAR' : '‚ùå N√ÉO PARTICIPAR'}
`;
                        }
                        else {
                            finalReport += `

**WORKFLOW PARADO:** An√°lise jur√≠dica insuficiente (Score: ${legalScore}/100)
**RECOMENDA√á√ÉO:** ‚ùå N√ÉO PARTICIPAR - Problemas documentais cr√≠ticos
`;
                        }
                    }
                    else {
                        finalReport += `

**WORKFLOW PARADO:** Capacidade operacional insuficiente (Score: ${operationalScore}/100)
**RECOMENDA√á√ÉO:** ‚ùå N√ÉO PARTICIPAR - Falta de capacidade operacional
`;
                    }
                }
                else {
                    finalReport += `

**WORKFLOW PARADO:** Ader√™ncia estrat√©gica insuficiente (Score: ${strategicScore}/100)
**RECOMENDA√á√ÉO:** ‚ùå N√ÉO PARTICIPAR - N√£o alinhado com core business
`;
                }
                workflowResult = {
                    status: 'success',
                    result: {
                        finalReport,
                        status: 'completed',
                        validationScore: strategicScore
                    }
                };
                console.log('‚úÖ An√°lise sequencial executada com sucesso!');
            }
            catch (workflowErr) {
                console.error('‚ùå ERRO NO WORKFLOW:', workflowErr);
                console.error('‚ùå ERRO STACK:', workflowErr.stack);
                workflowError = workflowErr.message || 'Erro desconhecido no workflow';
                // Criar workflowResult falso para continuar
                workflowResult = {
                    status: 'error',
                    result: null
                };
            }
            let finalReport;
            let status;
            let validationScore = 0;
            // DEBUG: Analisar estrutura do workflowResult
            console.log('üîç DEBUG workflowResult STATUS:', workflowResult.status);
            console.log('üîç DEBUG workflowResult.steps keys:', Object.keys(workflowResult.steps || {}));
            console.log('üîç DEBUG workflowResult.result:', workflowResult.status ? 'EXISTS' : 'NOT EXISTS');
            if (workflowError) {
                console.log('üîç DEBUG workflow teve erro:', workflowError);
                finalReport = `RELAT√ìRIO DE AN√ÅLISE T√âCNICA - ERRO NO WORKFLOW\n\nLicita√ß√£o: ${request.licitacaoId}\nEmpresa: ${request.empresaId}\n\nStatus: Erro na execu√ß√£o do workflow\nErro: ${workflowError}\nDocumentos processados: ${ragResult.documentsCount}\n\nO sistema RAG processou os documentos com sucesso, mas o workflow de an√°lise falhou. Verifique a configura√ß√£o do Mastra.`;
                status = 'error';
            }
            else if (workflowResult.status === 'success') {
                // O resultado do workflow est√° em workflowResult.result['compile-final-report']
                const workflowOutput = workflowResult.result?.['compile-final-report'] || workflowResult.result;
                console.log('üîç DEBUG workflowOutput keys:', workflowOutput ? Object.keys(workflowOutput) : 'workflowOutput is null/undefined');
                console.log('üîç DEBUG workflowOutput full:', JSON.stringify(workflowOutput, null, 2));
                finalReport = workflowOutput?.relatorioCompleto || workflowOutput?.finalReport || 'Relat√≥rio n√£o gerado pelo workflow';
                status = workflowOutput?.status || 'completed';
                validationScore = workflowOutput?.qualityScore || workflowOutput?.validationScore || 0;
                // VALIDA√á√ÉO CR√çTICA - garantir que finalReport n√£o √© undefined/null/empty
                if (!finalReport || finalReport.trim().length === 0) {
                    finalReport = `RELAT√ìRIO DE AN√ÅLISE T√âCNICA\n\nLicita√ß√£o: ${request.licitacaoId}\nEmpresa: ${request.empresaId}\n\nStatus: An√°lise processada com sucesso\nDocumentos processados: ${ragResult.documentsCount}\n\nObserva√ß√£o: O workflow foi executado mas n√£o retornou conte√∫do detalhado. Verifique a configura√ß√£o dos agentes.`;
                    console.warn('‚ö†Ô∏è Workflow n√£o retornou finalReport, usando fallback');
                }
                console.log('üîç DEBUG FINAL extracted values:');
                console.log('  - finalReport length:', finalReport.length);
                console.log('  - finalReport preview:', finalReport.substring(0, 200) + '...');
                console.log('  - status:', status);
                console.log('  - validationScore:', validationScore);
            }
            else {
                console.log('üîç DEBUG workflow failed with status:', workflowResult.status);
                console.log('üîç DEBUG workflow error details:', JSON.stringify(workflowResult, null, 2));
                finalReport = `RELAT√ìRIO DE AN√ÅLISE T√âCNICA - FALHA\n\nLicita√ß√£o: ${request.licitacaoId}\nEmpresa: ${request.empresaId}\n\nStatus: Workflow retornou status de falha\nDetalhes: ${workflowResult.status}\nDocumentos processados: ${ragResult.documentsCount}\n\nEm caso de d√∫vidas, entre em contato com o suporte t√©cnico.`;
                status = 'error';
            }
            console.log('üìÑ Preparando dados para PDF...');
            console.log('üìÑ finalReport length:', finalReport?.length || 0);
            console.log('üìÑ finalReport type:', typeof finalReport);
            const technicalSummary = (0, hooks_1.extractTechnicalSummary)(finalReport);
            const impugnacaoAnalysis = (0, hooks_1.extractImpugnacaoAnalysis)(finalReport);
            console.log('üìÑ technicalSummary length:', technicalSummary?.length || 0);
            console.log('üìÑ impugnacaoAnalysis length:', impugnacaoAnalysis?.length || 0);
            const pdfData = {
                licitacaoId: request.licitacaoId,
                empresa: request.empresaCNPJ,
                dataAnalise: new Date().toLocaleString('pt-BR'),
                finalReport,
                technicalSummary,
                impugnacaoAnalysis,
                documentsAnalyzed: ragResult.documentsCount,
                totalCharacters: 0
            };
            console.log('üìÑ Gerando PDF com dados:', JSON.stringify({
                licitacaoId: pdfData.licitacaoId,
                empresa: pdfData.empresa,
                finalReportLength: pdfData.finalReport?.length || 0,
                technicalSummaryLength: pdfData.technicalSummary?.length || 0,
                impugnacaoAnalysisLength: pdfData.impugnacaoAnalysis?.length || 0
            }));
            const { pdfPath, dadosPdf } = await (0, hooks_1.generatePDFReport)(pdfData);
            // Salvar relat√≥rio no Supabase Storage se empresaCNPJ fornecido
            if (request.empresaCNPJ) {
                try {
                    await this.relatoriosService.salvarRelatorio(request.empresaCNPJ, request.licitacaoId, pdfPath, relatorioStorageService_1.TipoRelatorio.ANALISE_COMPLETA, {
                        qualityScore: validationScore,
                        processedAt: new Date().toISOString(),
                        documentsAnalyzed: ragResult.documentsCount,
                        totalCharacters: finalReport?.length || 0
                    }, dadosPdf);
                    console.log('‚úÖ Relat√≥rio salvo no Supabase Storage com dados estruturados');
                }
                catch (storageError) {
                    console.error('‚ö†Ô∏è Erro ao salvar relat√≥rio no storage:', storageError);
                }
            }
            return {
                status: status,
                licitacaoId: request.licitacaoId,
                processedAt: new Date().toISOString(),
                pdfPath,
                technicalSummary: (0, hooks_1.extractTechnicalSummary)(finalReport),
                impugnacaoAnalysis: (0, hooks_1.extractImpugnacaoAnalysis)(finalReport),
                finalReport,
                validationScore,
            };
        }
        catch (error) {
            console.error('‚ùå ERRO CR√çTICO em analyzeEdital:', error);
            console.error('‚ùå ERRO STACK:', error.stack);
            console.error('‚ùå ERRO TYPE:', typeof error);
            console.error('‚ùå ERRO MESSAGE:', error.message);
            console.error('‚ùå ERRO DETAILS:', JSON.stringify(error, null, 2));
            return {
                licitacaoId: request.licitacaoId,
                technicalSummary: "",
                impugnacaoAnalysis: "",
                finalReport: `Erro no processamento: ${error}`,
                status: "error",
                processedAt: new Date().toISOString(),
                validationScore: 0,
            };
        }
    }
    async queryEdital(licitacaoId, query, topK = 10) {
        return await this.ragService.queryEdital(licitacaoId, query, topK);
    }
    async isEditalProcessed(licitacaoId) {
        return await this.ragService.isEditalProcessed(licitacaoId);
    }
}
exports.EditalAnalysisService = EditalAnalysisService;
/**
 * Helper function to extract score from agent response text
 */
function extractScoreFromText(text) {
    const scoreMatches = text.match(/(?:SCORE|Score)[\s:]+(\d+)(?:\/100)?/gi);
    if (scoreMatches && scoreMatches.length > 0) {
        const lastMatch = scoreMatches[scoreMatches.length - 1];
        const scoreNumber = lastMatch.match(/(\d+)/);
        if (scoreNumber) {
            return Math.min(100, Math.max(0, parseInt(scoreNumber[1])));
        }
    }
    // Fallback: estimate score based on text length and content
    return Math.max(0, Math.min(100, Math.round(text.length / 50)));
}

#!/usr/bin/env ts-node
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const dotenv_1 = __importDefault(require("dotenv"));
const path_1 = __importDefault(require("path"));
const promises_1 = __importDefault(require("fs/promises"));
// Carregar vari√°veis de ambiente explicitamente
dotenv_1.default.config({ path: path_1.default.resolve(__dirname, '../../.env') });
// Verificar se OPENAI_API_KEY est√° carregada
if (!process.env.OPENAI_API_KEY) {
    console.error('‚ùå OPENAI_API_KEY n√£o encontrada no arquivo .env');
    console.error('üìù Verifique se o arquivo .env est√° na raiz do projeto com:');
    console.error('   OPENAI_API_KEY=sua_chave_aqui');
    console.log('üîç Tentando carregar de:', path_1.default.resolve(__dirname, '../../.env'));
    process.exit(1);
}
console.log('‚úÖ OPENAI_API_KEY carregada com sucesso');
const mastra_1 = require("../mastra");
const RAGService_1 = require("../services/edital/RAGService");
const pdfGeneratorAdapter_1 = require("../adapters/pdfGeneratorAdapter");
// ========================================
// CONFIGURA√á√ÉO DO TESTE
// ========================================
const TEST_CONFIG = {
    // Altere este path para testar diferentes editais
    documentPath: '/Users/pedrotorrezani/Documents/Programacao/alicit2.0/backend/documents/edital_maripora/',
    // ID fict√≠cio para o teste (pode ser qualquer string)
    licitacaoId: 'TEST_MARIPORA_90005_2025',
    // ID da empresa (opcional)
    empresaId: 'EMPRESA_TESTE_LTDA',
    // Configura√ß√µes de debug
    verbose: true,
    saveResults: true,
    resultsDir: '/Users/pedrotorrezani/Documents/Programacao/alicit2.0/backend/test-results/',
};
// ========================================
// CLASSE PRINCIPAL DE TESTE
// ========================================
class EditalWorkflowTester {
    constructor() {
        this.config = TEST_CONFIG;
        this.log('üöÄ Iniciando Teste do Workflow de An√°lise de Edital');
        this.log(`üìÅ Documento: ${this.config.documentPath}`);
        this.log(`üÜî Licita√ß√£o ID: ${this.config.licitacaoId}`);
        // Inicializar servi√ßos
        const redisUrl = process.env.REDIS_URL || "redis://localhost:6379";
        this.ragService = new RAGService_1.EditalRAGService(redisUrl);
        this.pdfGenerator = new pdfGeneratorAdapter_1.PDFGeneratorAdapter();
    }
    log(message, type = 'info') {
        if (!this.config.verbose && type === 'info')
            return;
        const icons = {
            info: '‚ÑπÔ∏è',
            success: '‚úÖ',
            error: '‚ùå',
            warn: '‚ö†Ô∏è'
        };
        const timestamp = new Date().toLocaleTimeString('pt-BR');
        console.log(`[${timestamp}] ${icons[type]} ${message}`);
    }
    /**
     * Processa os documentos usando o RAGService real
     */
    async processRAGDocuments() {
        this.log('üìö Processando documentos com RAGService real...');
        try {
            // Verificar se o diret√≥rio existe
            const files = await promises_1.default.readdir(this.config.documentPath);
            const documentFiles = files.filter(file => file.endsWith('.pdf') || file.endsWith('.txt') || file.endsWith('.docx'));
            if (documentFiles.length === 0) {
                throw new Error('Nenhum documento encontrado no diret√≥rio especificado');
            }
            this.log(`üìÑ Encontrados ${documentFiles.length} documento(s): ${documentFiles.join(', ')}`);
            // Ler os arquivos e converter para o formato esperado
            const documents = [];
            for (const filename of documentFiles) {
                const filePath = path_1.default.join(this.config.documentPath, filename);
                const buffer = await promises_1.default.readFile(filePath);
                documents.push({
                    filename,
                    buffer,
                    mimetype: filename.endsWith('.pdf') ? 'application/pdf' :
                        filename.endsWith('.docx') ? 'application/vnd.openxmlformats-officedocument.wordprocessingml.document' :
                            'text/plain',
                    size: buffer.length
                });
                this.log(`üìÑ Arquivo carregado: ${filename} (${buffer.length} bytes)`);
            }
            // Inicializar RAG Service
            await this.ragService.initialize();
            // Processar o edital usando o RAGService real com array de documentos
            const ragResult = await this.ragService.processEdital({
                licitacaoId: this.config.licitacaoId,
                empresaId: this.config.empresaId,
                documents: documents
            });
            this.log(`‚úÖ RAG processado - ${ragResult.documentsCount} documentos, ${ragResult.chunksCount} chunks`, 'success');
            return {
                documentsCount: ragResult.documentsCount,
                chunksCount: ragResult.chunksCount
            };
        }
        catch (error) {
            this.log(`Erro no processamento RAG: ${error}`, 'error');
            throw error;
        }
    }
    /**
     * Executa o workflow completo de an√°lise
     */
    async executeWorkflow() {
        this.log('ü§ñ Executando workflow multi-agente...');
        try {
            const workflow = mastra_1.mastra.getWorkflow('editalAnalysisWorkflow');
            if (!workflow) {
                throw new Error('Workflow editalAnalysisWorkflow n√£o encontrado');
            }
            this.log('üìã Criando execu√ß√£o do workflow...');
            const run = await workflow.createRunAsync();
            const inputData = {
                licitacaoId: this.config.licitacaoId,
                empresaId: this.config.empresaId,
                refinementAttempts: 0
            };
            this.log('‚ö° Iniciando execu√ß√£o dos agentes especialistas...');
            const startTime = Date.now();
            const result = await run.start({ inputData });
            const executionTime = Date.now() - startTime;
            this.log(`üéâ Workflow executado em ${executionTime}ms`, 'success');
            return {
                result,
                executionTime,
                inputData
            };
        }
        catch (error) {
            this.log(`Erro na execu√ß√£o do workflow: ${error}`, 'error');
            throw error;
        }
    }
    /**
     * Analisa e exibe os resultados
     */
    async analyzeResults(workflowResult) {
        this.log('üìä Analisando resultados da execu√ß√£o...');
        try {
            if (workflowResult.result.status !== 'success') {
                this.log(`‚ùå Workflow falhou com status: ${workflowResult.result.status}`, 'error');
                console.log('Detalhes do erro:', JSON.stringify(workflowResult.result, null, 2));
                return;
            }
            const analysis = workflowResult.result.result?.['compile-final-report'] || workflowResult.result.result;
            if (!analysis) {
                this.log('‚ùå Resultado da an√°lise n√£o encontrado', 'error');
                return;
            }
            // Estat√≠sticas gerais
            this.log('\nüìà ESTAT√çSTICAS DA AN√ÅLISE:', 'success');
            console.log(`‚Ä¢ Score de Qualidade: ${analysis.qualityScore}/100`);
            console.log(`‚Ä¢ Status: ${analysis.status}`);
            console.log(`‚Ä¢ An√°lise Completa: ${analysis.isComplete ? 'Sim' : 'N√£o'}`);
            console.log(`‚Ä¢ Tempo de Execu√ß√£o: ${workflowResult.executionTime}ms`);
            console.log(`‚Ä¢ Tentativas de Refinamento: ${analysis.executionMetadata?.refinementAttempts || 0}`);
            console.log(`‚Ä¢ Agentes Executados: ${analysis.executionMetadata?.totalAgentsExecuted || 0}`);
            console.log(`‚Ä¢ Contexto Processado: ${analysis.executionMetadata?.contextoProcessado || 0} chars`);
            // Recomenda√ß√µes
            if (analysis.recommendations && analysis.recommendations.length > 0) {
                this.log('\nüí° RECOMENDA√á√ïES:', 'success');
                analysis.recommendations.forEach((rec, index) => {
                    console.log(`${index + 1}. ${rec}`);
                });
            }
            // Preview do relat√≥rio
            if (analysis.relatorioCompleto) {
                this.log('\nüìã PREVIEW DO RELAT√ìRIO:', 'success');
                const preview = analysis.relatorioCompleto.substring(0, 500);
                console.log(`${preview}${analysis.relatorioCompleto.length > 500 ? '...\n[RELAT√ìRIO COMPLETO SALVO NO ARQUIVO]' : ''}`);
            }
            return analysis;
        }
        catch (error) {
            this.log(`Erro na an√°lise dos resultados: ${error}`, 'error');
            throw error;
        }
    }
    /**
     * Gera PDF do relat√≥rio usando PDFGeneratorAdapter
     */
    async generatePDFReport(analysis, ragInfo) {
        try {
            if (!analysis?.relatorioCompleto) {
                this.log('‚ö†Ô∏è Relat√≥rio n√£o encontrado, pulando gera√ß√£o de PDF', 'warn');
                return null;
            }
            this.log('üìÑ Gerando PDF do relat√≥rio...');
            const pdfData = {
                licitacaoId: this.config.licitacaoId,
                empresa: this.config.empresaId,
                dataAnalise: new Date().toLocaleString('pt-BR'),
                technicalSummary: this.extractSectionFromReport(analysis.relatorioCompleto, '## üìã AN√ÅLISE DE OBJETO E ESCOPO', '## ‚è∞'),
                impugnacaoAnalysis: this.extractSectionFromReport(analysis.relatorioCompleto, '## üéØ IMPUGNA√á√ïES E ESCLARECIMENTOS', '## üìà'),
                finalReport: analysis.relatorioCompleto,
                documentsAnalyzed: ragInfo?.documentsCount || 0,
                totalCharacters: ragInfo?.chunksCount || 0
            };
            const pdfPath = await this.pdfGenerator.generateReport(pdfData);
            this.log(`üìÑ PDF gerado com sucesso: ${pdfPath}`, 'success');
            return pdfPath;
        }
        catch (error) {
            this.log(`Erro na gera√ß√£o do PDF: ${error}`, 'error');
            return null;
        }
    }
    /**
     * Extrai uma se√ß√£o espec√≠fica do relat√≥rio markdown
     */
    extractSectionFromReport(report, startMarker, endMarker) {
        const startIndex = report.indexOf(startMarker);
        if (startIndex === -1)
            return 'Se√ß√£o n√£o encontrada';
        const endIndex = report.indexOf(endMarker, startIndex);
        const sectionEnd = endIndex === -1 ? report.length : endIndex;
        return report.substring(startIndex, sectionEnd).trim();
    }
    /**
     * Salva os resultados em arquivos para an√°lise posterior
     */
    async saveResults(analysis, workflowResult, ragInfo) {
        if (!this.config.saveResults)
            return;
        try {
            this.log('üíæ Salvando resultados...');
            // Criar diret√≥rio de resultados se n√£o existir
            await promises_1.default.mkdir(this.config.resultsDir, { recursive: true });
            const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
            const baseFilename = `test-${this.config.licitacaoId}-${timestamp}`;
            // Salvar relat√≥rio completo em Markdown
            if (analysis?.relatorioCompleto) {
                const reportPath = path_1.default.join(this.config.resultsDir, `${baseFilename}-relatorio.md`);
                await promises_1.default.writeFile(reportPath, analysis.relatorioCompleto, 'utf-8');
                this.log(`üìÑ Relat√≥rio completo salvo em: ${reportPath}`, 'success');
            }
            // Gerar PDF do relat√≥rio
            const pdfPath = await this.generatePDFReport(analysis, ragInfo);
            if (pdfPath) {
                // Copiar PDF para diret√≥rio de resultados com nome consistente
                const pdfDestination = path_1.default.join(this.config.resultsDir, `${baseFilename}-relatorio.pdf`);
                try {
                    await promises_1.default.copyFile(pdfPath, pdfDestination);
                    this.log(`üìÑ PDF copiado para: ${pdfDestination}`, 'success');
                }
                catch (copyError) {
                    this.log(`‚ö†Ô∏è Erro ao copiar PDF: ${copyError}`, 'warn');
                }
            }
            // Salvar dados brutos em JSON
            const rawDataPath = path_1.default.join(this.config.resultsDir, `${baseFilename}-raw.json`);
            const rawData = {
                config: this.config,
                executionTime: workflowResult.executionTime,
                inputData: workflowResult.inputData,
                result: analysis,
                ragInfo,
                timestamp: new Date().toISOString(),
            };
            await promises_1.default.writeFile(rawDataPath, JSON.stringify(rawData, null, 2), 'utf-8');
            this.log(`üìä Dados brutos salvos em: ${rawDataPath}`, 'success');
            // Salvar sum√°rio em TXT
            const summaryPath = path_1.default.join(this.config.resultsDir, `${baseFilename}-summary.txt`);
            const summary = `
TESTE DE WORKFLOW - AN√ÅLISE DE EDITAL
=====================================

Configura√ß√£o:
‚Ä¢ Documento: ${this.config.documentPath}
‚Ä¢ Licita√ß√£o ID: ${this.config.licitacaoId}
‚Ä¢ Empresa ID: ${this.config.empresaId}
‚Ä¢ Timestamp: ${new Date().toLocaleString('pt-BR')}

Processamento RAG:
‚Ä¢ Documentos Processados: ${ragInfo?.documentsCount || 0}
‚Ä¢ Chunks Gerados: ${ragInfo?.chunksCount || 0}

Resultados:
‚Ä¢ Score de Qualidade: ${analysis?.qualityScore || 'N/A'}/100
‚Ä¢ Status: ${analysis?.status || 'N/A'}
‚Ä¢ An√°lise Completa: ${analysis?.isComplete ? 'Sim' : 'N√£o'}
‚Ä¢ Tempo de Execu√ß√£o: ${workflowResult.executionTime}ms
‚Ä¢ Tentativas de Refinamento: ${analysis?.executionMetadata?.refinementAttempts || 0}

Recomenda√ß√µes:
${analysis?.recommendations?.map((rec, i) => `${i + 1}. ${rec}`).join('\n') || 'Nenhuma recomenda√ß√£o'}
`;
            await promises_1.default.writeFile(summaryPath, summary, 'utf-8');
            this.log(`üìã Sum√°rio salvo em: ${summaryPath}`, 'success');
        }
        catch (error) {
            this.log(`Erro ao salvar resultados: ${error}`, 'warn');
        }
    }
    /**
     * Executa o teste completo
     */
    async runCompleteTest() {
        const overallStartTime = Date.now();
        try {
            this.log('üé¨ Iniciando teste completo do workflow...');
            // 1. Processar documentos com RAG real
            const ragInfo = await this.processRAGDocuments();
            // 2. Executar workflow
            const workflowResult = await this.executeWorkflow();
            // 3. Analisar resultados
            const analysis = await this.analyzeResults(workflowResult);
            // 4. Salvar resultados
            if (analysis) {
                await this.saveResults(analysis, workflowResult, ragInfo);
            }
            const totalTime = Date.now() - overallStartTime;
            this.log(`üèÅ TESTE CONCLU√çDO EM ${totalTime}ms`, 'success');
            return {
                success: true,
                totalTime,
                analysis
            };
        }
        catch (error) {
            const totalTime = Date.now() - overallStartTime;
            this.log(`üí• TESTE FALHOU AP√ìS ${totalTime}ms: ${error}`, 'error');
            return {
                success: false,
                totalTime,
                error: error instanceof Error ? error.message : String(error)
            };
        }
    }
}
// ========================================
// EXECU√á√ÉO PRINCIPAL
// ========================================
async function main() {
    const tester = new EditalWorkflowTester();
    const result = await tester.runCompleteTest();
    console.log('\n' + '='.repeat(60));
    console.log(result.success ? '‚úÖ TESTE CONCLU√çDO COM SUCESSO' : '‚ùå TESTE FALHOU');
    console.log('='.repeat(60));
    process.exit(result.success ? 0 : 1);
}
// Executar apenas se chamado diretamente
if (require.main === module) {
    main().catch((error) => {
        console.error('Erro fatal:', error);
        process.exit(1);
    });
}

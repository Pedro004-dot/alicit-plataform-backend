"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.editalAnalysisWorkflow = void 0;
const workflows_1 = require("@mastra/core/workflows");
const zod_1 = require("zod");
// Importar agentes especialistas
const scopeAgent_1 = require("../agents/specialists/scopeAgent");
const timelineAgent_1 = require("../agents/specialists/timelineAgent");
const eligibilityAgent_1 = require("../agents/specialists/eligibilityAgent");
const riskAgent_1 = require("../agents/specialists/riskAgent");
const challengeAgent_1 = require("../agents/specialists/challengeAgent");
const qualityControlAgent_1 = require("../agents/qualityControlAgent");
// Schema de contexto da empresa
const empresaContextSchema = zod_1.z.object({
    nome: zod_1.z.string(),
    descricao: zod_1.z.string(),
    porte: zod_1.z.string(),
    produtos: zod_1.z.array(zod_1.z.string()),
    servicos: zod_1.z.array(zod_1.z.string()),
    cidade: zod_1.z.string(),
    responsavel_legal: zod_1.z.string()
}).optional();
// Schema de entrada para o workflow orquestrador
const editalAnalysisInputSchema = zod_1.z.object({
    licitacaoId: zod_1.z.string().describe("ID da licita√ß√£o a ser analisada"),
    empresaId: zod_1.z.string().optional().describe("ID da empresa cliente (opcional)"),
    empresaContext: empresaContextSchema.describe("Contexto da empresa para personaliza√ß√£o da an√°lise"),
    refinementAttempts: zod_1.z.number().default(0).describe("N√∫mero de tentativas de refinamento"),
});
// Schema de sa√≠da do workflow orquestrador
const editalAnalysisOutputSchema = zod_1.z.object({
    relatorioCompleto: zod_1.z.string().describe("Relat√≥rio t√©cnico completo em Markdown"),
    qualityScore: zod_1.z.number().min(0).max(100).describe("Score de qualidade da an√°lise (0-100)"),
    status: zod_1.z.enum(["completed", "incomplete", "error"]).describe("Status final da an√°lise"),
    isComplete: zod_1.z.boolean().describe("Se a an√°lise est√° completa e aprovada"),
    recommendations: zod_1.z.array(zod_1.z.string()).describe("Recomenda√ß√µes de a√ß√£o baseadas na an√°lise"),
    executionMetadata: zod_1.z.object({
        totalAgentsExecuted: zod_1.z.number(),
        totalTimeMs: zod_1.z.number(),
        contextoProcessado: zod_1.z.number(),
        refinementAttempts: zod_1.z.number().describe("N√∫mero de tentativas de refinamento"),
    }).describe("Metadados de execu√ß√£o do workflow")
});
// Step 1: Execu√ß√£o dos agentes especialistas
const executeSpecialistAgentsStep = (0, workflows_1.createStep)({
    id: "execute-specialist-agents",
    description: "Executa todos os agentes especialistas em paralelo",
    inputSchema: editalAnalysisInputSchema,
    outputSchema: zod_1.z.object({
        scopeAnalysis: zod_1.z.string(),
        timelineAnalysis: zod_1.z.string(),
        eligibilityAnalysis: zod_1.z.string(),
        riskAnalysis: zod_1.z.string(),
        challengeAnalysis: zod_1.z.string(),
        executionTime: zod_1.z.number(),
        contextoTotal: zod_1.z.number(),
        refinementAttempts: zod_1.z.number(),
        empresaContext: empresaContextSchema,
    }),
    execute: async ({ inputData }) => {
        const startTime = Date.now();
        const { licitacaoId, empresaId = 'EMPRESA_GENERICA', empresaContext, refinementAttempts = 0 } = inputData;
        console.log(`üöÄ Executando agentes especialistas - Tentativa ${refinementAttempts + 1}`);
        // Preparar contexto da empresa para os prompts
        const empresaInfo = empresaContext ? {
            nome: empresaContext.nome,
            descricao: empresaContext.descricao,
            porte: empresaContext.porte,
            produtos: empresaContext.produtos.join(', ') || 'N√£o especificados',
            servicos: empresaContext.servicos.join(', ') || 'N√£o especificados',
            cidade: empresaContext.cidade,
            responsavel: empresaContext.responsavel_legal
        } : null;
        console.log(`üè¢ Contexto da empresa: ${empresaInfo ? `${empresaInfo.nome} (${empresaContext?.produtos.length} produtos, ${empresaContext?.servicos.length} servi√ßos)` : 'N√£o dispon√≠vel'}`);
        try {
            // Executar todos os agentes em paralelo com contexto enriquecido
            const [scopeResult, timelineResult, eligibilityResult, riskResult, challengeResult] = await Promise.all([
                // ScopeAgent - An√°lise de escopo contextualizada
                scopeAgent_1.scopeAgent.generate(empresaInfo ? `
CONTEXTO DA EMPRESA:
‚Ä¢ Nome: ${empresaInfo.nome}
‚Ä¢ Descri√ß√£o: ${empresaInfo.descricao}
‚Ä¢ Porte: ${empresaInfo.porte}
‚Ä¢ Produtos: ${empresaInfo.produtos}
‚Ä¢ Servi√ßos: ${empresaInfo.servicos}
‚Ä¢ Localiza√ß√£o: ${empresaInfo.cidade}

TAREFA: Analise detalhadamente o objeto e escopo da licita√ß√£o ${licitacaoId}.
Verifique ESPECIFICAMENTE o alinhamento com os produtos/servi√ßos da empresa.
Identifique oportunidades e incompatibilidades com o perfil empresarial.
Seja preciso e completo na an√°lise considerando as capacidades da empresa.
        ` : `Analise detalhadamente o objeto e escopo da licita√ß√£o ${licitacaoId}. Seja preciso e completo na an√°lise.`),
                // TimelineAgent - Timeline considerando porte da empresa
                timelineAgent_1.timelineAgent.generate(empresaInfo ? `
CONTEXTO DA EMPRESA:
‚Ä¢ Nome: ${empresaInfo.nome}
‚Ä¢ Porte: ${empresaInfo.porte}
‚Ä¢ Respons√°vel: ${empresaInfo.responsavel}

TAREFA: Extraia todos os prazos e eventos cr√≠ticos da licita√ß√£o ${licitacaoId}.
Construa uma timeline acion√°vel considerando o porte ${empresaInfo.porte} da empresa.
Destaque prazos cr√≠ticos que podem ser desafiadores para empresa de porte ${empresaInfo.porte}.
        ` : `Extraia todos os prazos e eventos cr√≠ticos da licita√ß√£o ${licitacaoId}. Construa uma timeline acion√°vel.`),
                // EligibilityAgent - Requisitos vs perfil da empresa
                eligibilityAgent_1.eligibilityAgent.generate(empresaInfo ? `
CONTEXTO DA EMPRESA:
‚Ä¢ Nome: ${empresaInfo.nome}
‚Ä¢ Porte: ${empresaInfo.porte}
‚Ä¢ Produtos: ${empresaInfo.produtos}
‚Ä¢ Servi√ßos: ${empresaInfo.servicos}
‚Ä¢ Cidade: ${empresaInfo.cidade}

TAREFA: Analise todos os requisitos de elegibilidade da licita√ß√£o ${licitacaoId}.
Crie checklist ESPEC√çFICO considerando:
- Compatibilidade com porte ${empresaInfo.porte}
- Adequa√ß√£o aos produtos/servi√ßos oferecidos
- Requisitos geogr√°ficos vs localiza√ß√£o em ${empresaInfo.cidade}
Identifique poss√≠veis obst√°culos para esta empresa espec√≠fica.
        ` : `Analise todos os requisitos de elegibilidade e qualifica√ß√£o da licita√ß√£o ${licitacaoId}. Crie checklist completo.`),
                // RiskAgent - Riscos proporcionais ao porte
                riskAgent_1.riskAgent.generate(empresaInfo ? `
CONTEXTO DA EMPRESA:
‚Ä¢ Nome: ${empresaInfo.nome}
‚Ä¢ Porte: ${empresaInfo.porte}
‚Ä¢ Descri√ß√£o: ${empresaInfo.descricao}
‚Ä¢ Produtos: ${empresaInfo.produtos}
‚Ä¢ Servi√ßos: ${empresaInfo.servicos}

TAREFA: Analise riscos contratuais da licita√ß√£o ${licitacaoId} ESPECIFICAMENTE para esta empresa.
Quantifique impactos financeiros proporcionais ao porte ${empresaInfo.porte}.
Avalie riscos espec√≠ficos considerando:
- Capacidade operacional do porte ${empresaInfo.porte}
- Compatibilidade com produtos/servi√ßos oferecidos
- Riscos t√©cnicos baseados na descri√ß√£o da empresa
Seja espec√≠fico nos valores e percentuais de risco.
        ` : `Analise riscos contratuais da licita√ß√£o ${licitacaoId} para empresa ${empresaId}. Quantifique impactos financeiros.`),
                // ChallengeAgent - Impugna√ß√µes baseadas no perfil
                challengeAgent_1.challengeAgent.generate(empresaInfo ? `
CONTEXTO DA EMPRESA:
‚Ä¢ Nome: ${empresaInfo.nome}
‚Ä¢ Porte: ${empresaInfo.porte}
‚Ä¢ Produtos: ${empresaInfo.produtos}
‚Ä¢ Servi√ßos: ${empresaInfo.servicos}
‚Ä¢ Descri√ß√£o: ${empresaInfo.descricao}

TAREFA: Identifique pontos para impugna√ß√£o da licita√ß√£o ${licitacaoId} que beneficiem esta empresa espec√≠fica.
Foque em aspectos que favore√ßam:
- Empresas de porte ${empresaInfo.porte}
- Fornecedores dos produtos/servi√ßos: ${empresaInfo.produtos} | ${empresaInfo.servicos}
Fundamente legalmente cada sugest√£o de impugna√ß√£o.
        ` : `Identifique pontos para impugna√ß√£o e esclarecimentos da licita√ß√£o ${licitacaoId}. Fundamente legalmente.`)
            ]);
            const scopeAnalysis = scopeResult.text || "An√°lise de escopo n√£o dispon√≠vel";
            const timelineAnalysis = timelineResult.text || "An√°lise de prazos n√£o dispon√≠vel";
            const eligibilityAnalysis = eligibilityResult.text || "An√°lise de elegibilidade n√£o dispon√≠vel";
            const riskAnalysis = riskResult.text || "An√°lise de riscos n√£o dispon√≠vel";
            const challengeAnalysis = challengeResult.text || "An√°lise de impugna√ß√µes n√£o dispon√≠vel";
            const executionTime = Date.now() - startTime;
            const contextoTotal = scopeAnalysis.length + timelineAnalysis.length + eligibilityAnalysis.length + riskAnalysis.length + challengeAnalysis.length;
            console.log(`‚úÖ Todos os agentes executados em ${executionTime}ms - Contexto: ${contextoTotal} chars`);
            return {
                scopeAnalysis,
                timelineAnalysis,
                eligibilityAnalysis,
                riskAnalysis,
                challengeAnalysis,
                executionTime,
                contextoTotal,
                refinementAttempts: refinementAttempts + 1,
                empresaContext // Passar contexto para pr√≥ximo step
            };
        }
        catch (error) {
            console.error('‚ùå Erro na execu√ß√£o dos agentes:', error);
            return {
                scopeAnalysis: "Erro na an√°lise de escopo",
                timelineAnalysis: "Erro na an√°lise de prazos",
                eligibilityAnalysis: "Erro na an√°lise de elegibilidade",
                riskAnalysis: "Erro na an√°lise de riscos",
                challengeAnalysis: "Erro na an√°lise de impugna√ß√µes",
                executionTime: Date.now() - startTime,
                contextoTotal: 0,
                refinementAttempts: refinementAttempts + 1,
                empresaContext // Passar contexto mesmo em caso de erro
            };
        }
    }
});
// Step 2: Controle de qualidade
const qualityControlStep = (0, workflows_1.createStep)({
    id: "quality-control",
    description: "Avalia qualidade das an√°lises usando agente especializado",
    inputSchema: zod_1.z.object({
        scopeAnalysis: zod_1.z.string(),
        timelineAnalysis: zod_1.z.string(),
        eligibilityAnalysis: zod_1.z.string(),
        riskAnalysis: zod_1.z.string(),
        challengeAnalysis: zod_1.z.string(),
        executionTime: zod_1.z.number(),
        contextoTotal: zod_1.z.number(),
        refinementAttempts: zod_1.z.number(),
        empresaContext: empresaContextSchema,
    }),
    outputSchema: zod_1.z.object({
        qualityScore: zod_1.z.number().min(0).max(100),
        isApproved: zod_1.z.boolean(),
        shouldRetry: zod_1.z.boolean(),
        qualityFeedback: zod_1.z.string(),
        scopeAnalysis: zod_1.z.string(),
        timelineAnalysis: zod_1.z.string(),
        eligibilityAnalysis: zod_1.z.string(),
        riskAnalysis: zod_1.z.string(),
        challengeAnalysis: zod_1.z.string(),
        executionTime: zod_1.z.number(),
        contextoTotal: zod_1.z.number(),
        refinementAttempts: zod_1.z.number(),
        empresaContext: empresaContextSchema,
    }),
    execute: async ({ inputData }) => {
        const { scopeAnalysis, timelineAnalysis, eligibilityAnalysis, riskAnalysis, challengeAnalysis, executionTime, contextoTotal, refinementAttempts, empresaContext } = inputData;
        console.log(`üîç Executando controle de qualidade - Tentativa ${refinementAttempts}`);
        try {
            // Preparar contexto enriquecido para an√°lise de qualidade
            const empresaInfo = empresaContext ? `
CONTEXTO DA EMPRESA ANALISADA:
‚Ä¢ Nome: ${empresaContext.nome}
‚Ä¢ Descri√ß√£o: ${empresaContext.descricao}
‚Ä¢ Porte: ${empresaContext.porte}
‚Ä¢ Produtos: ${empresaContext.produtos.join(', ') || 'N√£o especificados'}
‚Ä¢ Servi√ßos: ${empresaContext.servicos.join(', ') || 'N√£o especificados'}
‚Ä¢ Localiza√ß√£o: ${empresaContext.cidade}

` : 'CONTEXTO DA EMPRESA: N√£o dispon√≠vel\n\n';
            const qualityContext = `${empresaInfo}AN√ÅLISES PARA AVALIA√á√ÉO DE QUALIDADE:

## AN√ÅLISE DE ESCOPO (ScopeAgent)
${scopeAnalysis}

## AN√ÅLISE DE PRAZOS (TimelineAgent) 
${timelineAnalysis}

## AN√ÅLISE DE ELEGIBILIDADE (EligibilityAgent)
${eligibilityAnalysis}

## AN√ÅLISE DE RISCOS (RiskAgent)
${riskAnalysis}

## AN√ÅLISE DE IMPUGNA√á√ïES (ChallengeAgent)
${challengeAnalysis}

---

CRIT√âRIOS DE AVALIA√á√ÉO ESPEC√çFICOS:
1. **Contextualiza√ß√£o**: As an√°lises consideram adequadamente o perfil da empresa (porte, produtos/servi√ßos)?
2. **Especificidade**: As recomenda√ß√µes s√£o espec√≠ficas para esta empresa ou gen√©ricas?
3. **Completude**: Todas as se√ß√µes est√£o completas e detalhadas?
4. **Precis√£o**: As an√°lises s√£o t√©cnicas e fundamentadas?
5. **Acionabilidade**: As recomenda√ß√µes s√£o pr√°ticas e implement√°veis?

AVALIE a qualidade de cada an√°lise segundo estes crit√©rios especializados.
${empresaContext ? `Considere ESPECIALMENTE se as an√°lises foram personalizadas para uma empresa de porte ${empresaContext.porte} que atua com ${empresaContext.produtos.join(', ')} e ${empresaContext.servicos.join(', ')}.` : ''}

Forne√ßa um SCORE TOTAL de 0-100 e indique se est√° aprovada (score >= 75).
      `;
            // Executar agente de controle de qualidade
            const qualityResult = await qualityControlAgent_1.qualityControlAgent.generate(qualityContext);
            const qualityFeedback = qualityResult.text || "Avalia√ß√£o de qualidade n√£o dispon√≠vel";
            // Parser para extrair score da an√°lise
            let qualityScore = 50; // Score padr√£o conservador
            const scoreMatch = qualityFeedback.match(/SCORE TOTAL[:\s]*(\d+)\/100/i);
            if (scoreMatch) {
                qualityScore = parseInt(scoreMatch[1]);
            }
            else {
                // Fallback: an√°lise simples de completude
                const analysisLengths = [
                    scopeAnalysis.length,
                    timelineAnalysis.length,
                    eligibilityAnalysis.length,
                    riskAnalysis.length,
                    challengeAnalysis.length
                ];
                const avgLength = analysisLengths.reduce((a, b) => a + b, 0) / analysisLengths.length;
                qualityScore = Math.min(100, Math.max(20, (avgLength / 100) * 2)); // Score baseado em tamanho
            }
            const isApproved = qualityScore >= 75;
            const shouldRetry = !isApproved && refinementAttempts < 2; // M√°ximo 2 tentativas
            console.log(`üìä Score de qualidade: ${qualityScore}/100`);
            console.log(`üéØ Status: ${isApproved ? '‚úÖ Aprovado' : shouldRetry ? 'üîÑ Precisa refinamento' : '‚ö†Ô∏è Finalizando com limita√ß√µes'}`);
            return {
                qualityScore,
                isApproved,
                shouldRetry,
                qualityFeedback,
                scopeAnalysis,
                timelineAnalysis,
                eligibilityAnalysis,
                riskAnalysis,
                challengeAnalysis,
                executionTime,
                contextoTotal,
                refinementAttempts,
                empresaContext
            };
        }
        catch (error) {
            console.error('‚ùå Erro no controle de qualidade:', error);
            return {
                qualityScore: 40,
                isApproved: false,
                shouldRetry: false,
                qualityFeedback: `Erro na avalia√ß√£o de qualidade: ${error}`,
                scopeAnalysis,
                timelineAnalysis,
                eligibilityAnalysis,
                riskAnalysis,
                challengeAnalysis,
                executionTime,
                contextoTotal,
                refinementAttempts,
                empresaContext
            };
        }
    }
});
// Step 3: Compila√ß√£o do relat√≥rio final
const compileFinalReportStep = (0, workflows_1.createStep)({
    id: "compile-final-report",
    description: "Compila relat√≥rio t√©cnico final baseado nas an√°lises validadas",
    inputSchema: zod_1.z.object({
        qualityScore: zod_1.z.number(),
        isApproved: zod_1.z.boolean(),
        shouldRetry: zod_1.z.boolean(),
        qualityFeedback: zod_1.z.string(),
        scopeAnalysis: zod_1.z.string(),
        timelineAnalysis: zod_1.z.string(),
        eligibilityAnalysis: zod_1.z.string(),
        riskAnalysis: zod_1.z.string(),
        challengeAnalysis: zod_1.z.string(),
        executionTime: zod_1.z.number(),
        contextoTotal: zod_1.z.number(),
        refinementAttempts: zod_1.z.number(),
        empresaContext: empresaContextSchema,
    }),
    outputSchema: editalAnalysisOutputSchema,
    execute: async ({ inputData }) => {
        const { qualityScore, isApproved, scopeAnalysis, timelineAnalysis, eligibilityAnalysis, riskAnalysis, challengeAnalysis, executionTime, contextoTotal, refinementAttempts } = inputData;
        console.log(`üìù Compilando relat√≥rio t√©cnico final - Score: ${qualityScore}/100`);
        const relatorioCompleto = `
# RELAT√ìRIO T√âCNICO DE AN√ÅLISE DE EDITAL

**Data:** ${new Date().toLocaleString('pt-BR')}  
**Score de Qualidade:** ${qualityScore}/100  
**Status:** ${isApproved ? '‚úÖ AN√ÅLISE APROVADA' : '‚ö†Ô∏è AN√ÅLISE COM LIMITA√á√ïES'}  
**Tentativas de Refinamento:** ${refinementAttempts}  
**Tempo de Execu√ß√£o:** ${executionTime}ms  
**Contexto Processado:** ${contextoTotal.toLocaleString()} caracteres

---

## üéØ RESUMO EXECUTIVO

${isApproved ?
            'A an√°lise foi conclu√≠da com sucesso e aprovada pelo sistema de controle de qualidade. Todos os aspectos cr√≠ticos do edital foram analisados pelos agentes especialistas.' :
            'A an√°lise foi conclu√≠da mas apresenta limita√ß√µes identificadas pelo controle de qualidade. Recomenda-se cautela na tomada de decis√µes.'}

---

## üìã AN√ÅLISE DE OBJETO E ESCOPO

${scopeAnalysis}

---

## ‚è∞ PRAZOS E EVENTOS CR√çTICOS

${timelineAnalysis}

---

## ‚úÖ ELEGIBILIDADE E QUALIFICA√á√ÉO

${eligibilityAnalysis}

---

## ‚ö†Ô∏è AN√ÅLISE DE RISCOS CONTRATUAIS

${riskAnalysis}

---

## üéØ IMPUGNA√á√ïES E ESCLARECIMENTOS

${challengeAnalysis}

---

## üìà M√âTRICAS DE EXECU√á√ÉO

- **Agentes Especialistas Executados:** 5
- **Tentativas de Refinamento:** ${refinementAttempts}
- **Tempo Total de Processamento:** ${executionTime}ms
- **Volume de Contexto Analisado:** ${contextoTotal.toLocaleString()} caracteres
- **Score de Qualidade Final:** ${qualityScore}/100

---

## üèÅ RECOMENDA√á√ïES FINAIS

${isApproved ?
            'Com base na an√°lise completa e aprovada, recomenda-se prosseguir com a avalia√ß√£o detalhada da participa√ß√£o nesta licita√ß√£o, seguindo as orienta√ß√µes espec√≠ficas de cada se√ß√£o.' :
            'Devido √†s limita√ß√µes identificadas na an√°lise, recomenda-se revis√£o manual adicional e consulta especializada antes de decis√µes definitivas sobre a participa√ß√£o.'}

---

*Relat√≥rio gerado pelo Sistema Aut√¥nomo de Agentes Especialistas da Alicit*  
*Sistema de Controle de Qualidade Automatizado v2.0*  
*Primeira consultoria de licita√ß√µes p√∫blicas automatizada por IA do mundo*
    `.trim();
        // Definir recomenda√ß√µes baseadas na qualidade
        const recommendations = [];
        if (isApproved) {
            recommendations.push("Participar do processo licitat√≥rio seguindo orienta√ß√µes espec√≠ficas");
            recommendations.push("Revisar documentos de habilita√ß√£o conforme checklist detalhado");
            recommendations.push("Implementar estrat√©gias de mitiga√ß√£o de riscos identificados");
            recommendations.push("Considerar elabora√ß√£o de esclarecimentos/impugna√ß√µes sugeridas");
        }
        else {
            recommendations.push("Realizar revis√£o manual especializada complementar");
            recommendations.push("Coletar informa√ß√µes adicionais sobre pontos identificados como incompletos");
            recommendations.push("Considerar nova an√°lise com documenta√ß√£o mais completa do edital");
            recommendations.push("Consultar especialistas jur√≠dicos/t√©cnicos antes da decis√£o final");
        }
        const status = isApproved ? "completed" : "incomplete";
        console.log(`üéâ Relat√≥rio compilado com sucesso - Status: ${status}`);
        return {
            relatorioCompleto,
            qualityScore,
            status,
            isComplete: isApproved,
            recommendations,
            executionMetadata: {
                totalAgentsExecuted: 5,
                totalTimeMs: executionTime,
                contextoProcessado: contextoTotal,
                refinementAttempts
            }
        };
    }
});
// Workflow Orquestrador Aut√¥nomo - Vers√£o Simplificada
exports.editalAnalysisWorkflow = (0, workflows_1.createWorkflow)({
    id: "editalAnalysisWorkflow",
    description: "Workflow orquestrador aut√¥nomo com controle de qualidade integrado",
    inputSchema: editalAnalysisInputSchema,
    outputSchema: editalAnalysisOutputSchema,
})
    // Executa todos os agentes especialistas em paralelo
    .then(executeSpecialistAgentsStep)
    // Avalia qualidade usando agente especializado
    .then(qualityControlStep)
    // Decide se deve tentar refinamento ou compilar relat√≥rio final
    .branch([
    // Condi√ß√£o: qualidade insuficiente E ainda pode tentar refinamento
    [
        async ({ inputData }) => {
            return inputData.shouldRetry === true;
        },
        // Re-executa o workflow com tentativa incrementada
        (0, workflows_1.createStep)({
            id: "retry-analysis",
            description: "Re-executa an√°lise com tentativa incrementada",
            inputSchema: zod_1.z.object({
                qualityScore: zod_1.z.number(),
                isApproved: zod_1.z.boolean(),
                shouldRetry: zod_1.z.boolean(),
                qualityFeedback: zod_1.z.string(),
                scopeAnalysis: zod_1.z.string(),
                timelineAnalysis: zod_1.z.string(),
                eligibilityAnalysis: zod_1.z.string(),
                riskAnalysis: zod_1.z.string(),
                challengeAnalysis: zod_1.z.string(),
                executionTime: zod_1.z.number(),
                contextoTotal: zod_1.z.number(),
                refinementAttempts: zod_1.z.number(),
                empresaContext: empresaContextSchema,
            }),
            outputSchema: editalAnalysisOutputSchema,
            execute: async ({ inputData, mastra }) => {
                console.log(`üîÑ Iniciando refinamento - Tentativa ${inputData.refinementAttempts + 1}`);
                // Re-executar workflow com refinementAttempts incrementado
                const workflow = mastra?.getWorkflow('editalAnalysisWorkflow');
                if (workflow) {
                    const newRun = await workflow.createRunAsync();
                    const result = await newRun.start({
                        inputData: {
                            licitacaoId: 'retry', // TODO: Passar licitacaoId correto
                            empresaId: 'EMPRESA_GENERICA', // TODO: Passar empresaId correto
                            refinementAttempts: inputData.refinementAttempts
                        }
                    });
                    if (result.status === 'success' && result.result) {
                        return result.result;
                    }
                }
                // Fallback: compilar com dados atuais se n√£o conseguir re-executar
                return {
                    relatorioCompleto: `Erro no refinamento - compilando com dados atuais\n\n${inputData.qualityFeedback}`,
                    qualityScore: inputData.qualityScore,
                    status: "incomplete",
                    isComplete: false,
                    recommendations: ["Revis√£o manual necess√°ria devido a erro no refinamento"],
                    executionMetadata: {
                        totalAgentsExecuted: 5,
                        totalTimeMs: inputData.executionTime,
                        contextoProcessado: inputData.contextoTotal,
                        refinementAttempts: inputData.refinementAttempts + 1
                    }
                };
            }
        })
    ],
    // Condi√ß√£o padr√£o: compilar relat√≥rio final com dados atuais
    [
        async () => true,
        compileFinalReportStep
    ]
])
    .commit();

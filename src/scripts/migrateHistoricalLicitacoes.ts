import 'dotenv/config';
import PNCPLicitacaoAdapter from '../adapters/PNCPLicitacaoAdapter';
import licitacaoStorageService from '../services/licitacao/licitacaoStorageService';
import supabaseLicitacaoRepository from '../repositories/supabaseLicitacaoRepository';

export interface HistoricalMigrationParams {
  dataInicio: string; // 'YYYYMMDD'
  dataFim: string;    // 'YYYYMMDD'
  modalidades: number[];
  batchSizePaginas: number;
  delayBetweenBatches: number;
  // REMOVIDO: skipDuplicateCheck - n√£o √© mais necess√°rio com fluxo simplificado
}

export class HistoricalLicitacaoMigrator {
  private adapter = new PNCPLicitacaoAdapter();
  private processedCount = 0;
  private savedCount = 0;
  private skippedCount = 0;
  private supabaseSavedCount = 0;
  private pineconeSavedCount = 0;

  async executeMigration(params: HistoricalMigrationParams) {
    console.log(`üöÄ INICIANDO MIGRA√á√ÉO HIST√ìRICA`);
    console.log(`üìÖ Per√≠odo: ${params.dataInicio} ‚Üí ${params.dataFim}`);
    console.log(`üìã Modalidades: [${params.modalidades.join(', ')}]`);
    
    // üîß TESTE DE CONECTIVIDADE
    console.log(`üîç Testando conectividade dos bancos de dados...`);
    const supabaseOK = await supabaseLicitacaoRepository.testConnection();
    
    if (!supabaseOK) {
      console.error(`‚ùå Falha na conex√£o com Supabase. Abortando migra√ß√£o.`);
      return;
    }
    
    console.log(`‚úÖ Todos os bancos est√£o conectados. Iniciando migra√ß√£o...`);
    
    for (const modalidade of params.modalidades) {
      await this.processModalidade(modalidade, params);
      
      // Pausa entre modalidades
      console.log(`‚è∏Ô∏è Pausa de ${params.delayBetweenBatches}ms entre modalidades...`);
      await this.sleep(params.delayBetweenBatches);
    }
    
    console.log(`‚úÖ MIGRA√á√ÉO CONCLU√çDA`);
    console.log(`üìä Processadas: ${this.processedCount}`);
    console.log(`üíæ Salvas no Supabase: ${this.supabaseSavedCount}`);
    console.log(`üéØ Salvas no Pinecone: ${this.pineconeSavedCount}`);
    console.log(`‚è≠Ô∏è Ignoradas: ${this.skippedCount}`);
  }

  private async processModalidade(modalidade: number, params: HistoricalMigrationParams) {
    console.log(`\nüîÑ PROCESSANDO MODALIDADE ${modalidade}`);
    
    // 1. Descobrir total de p√°ginas
    const firstPage = await this.fetchPage(modalidade, params, 1);
    if (!firstPage) return;
    
    const totalPaginas = firstPage.totalPaginas;
    console.log(`üìÑ Modalidade ${modalidade}: ${firstPage.totalRegistros} registros em ${totalPaginas} p√°ginas`);
    
    // 2. Processar em batches
    for (let startPage = 1; startPage <= totalPaginas; startPage += params.batchSizePaginas) {
      const endPage = Math.min(startPage + params.batchSizePaginas - 1, totalPaginas);
      
      await this.processBatch(modalidade, params, startPage, endPage);
      
      // Pausa entre batches
      if (endPage < totalPaginas) {
        await this.sleep(params.delayBetweenBatches);
      }
    }
  }

  private async processBatch(modalidade: number, params: HistoricalMigrationParams, startPage: number, endPage: number) {
    console.log(`üì¶ Processando batch modalidade ${modalidade}: p√°ginas ${startPage}-${endPage}`);
    
    const licitacoesBatch: any[] = [];
    
    // Timeout de 5 minutos para o batch completo
    const timeoutPromise = new Promise<never>((_, reject) => {
      setTimeout(() => {
        reject(new Error(`Timeout de 5 minutos no batch p√°ginas ${startPage}-${endPage}`));
      }, 5 * 60 * 1000);
    });
    
    try {
      await Promise.race([
        this.processBatchInternal(modalidade, params, startPage, endPage, licitacoesBatch),
        timeoutPromise
      ]);
    } catch (error) {
      console.error(`‚ùå ERRO no batch p√°ginas ${startPage}-${endPage}:`, error);
    }
  }
  
  private async processBatchInternal(modalidade: number, params: HistoricalMigrationParams, startPage: number, endPage: number, licitacoesBatch: any[]) {
    try {
      // Buscar p√°ginas do batch em paralelo (controlado)
      const promises = [];
      let pagesProcessed = 0;
      
      for (let page = startPage; page <= endPage; page++) {
        promises.push(this.fetchPage(modalidade, params, page));
        
        // Requests sequenciais (conforme boas pr√°ticas PNCP)
        if (promises.length >= 1 || page === endPage) {
          const currentPages: number[] = [];
          for (let i = 0; i < promises.length; i++) {
            currentPages.push(startPage + pagesProcessed + i);
          }
          
          // Timeout para o grupo de requests
          const groupTimeoutPromise = new Promise<never>((_, reject) => {
            setTimeout(() => reject(new Error(`Timeout de 2 minutos no grupo de p√°ginas [${currentPages.join(', ')}]`)), 2 * 60 * 1000);
          });
          
          try {
            const results = await Promise.race([
              Promise.allSettled(promises),
              groupTimeoutPromise
            ]);
            
            let successCount = 0;
            results.forEach((result, index) => {
              const pageNum = startPage + pagesProcessed + index;
              if (result.status === 'fulfilled' && result.value?.data) {
                licitacoesBatch.push(...result.value.data);
                successCount++;
              } else {
                console.warn(`‚ö†Ô∏è P√°gina ${pageNum} falhou`);
              }
            });
            
            pagesProcessed += promises.length;
            console.log(`üìä P√°ginas ${currentPages[0]}-${currentPages[currentPages.length-1]}: ${successCount}/${promises.length} sucesso, ${licitacoesBatch.length} total`);
            
          } catch (error) {
            console.error(`‚ùå TIMEOUT no grupo de p√°ginas [${currentPages.join(', ')}]`);
            pagesProcessed += promises.length; // Continuar mesmo com erro
          }
          
          promises.length = 0; // Clear array
          
          if (page < endPage) {
            await this.sleep(2500); // Pausa padronizada com adapter (2.5s)
          }
        }
      }
      
      // Processar licita√ß√µes do batch
      await this.processLicitacoesBatch(licitacoesBatch);
      
    } catch (error) {
      console.error(`‚ùå ERRO CR√çTICO no batch interno:`, error);
    }
  }

  private async processLicitacoesBatch(licitacoes: any[]) {
    if (licitacoes.length === 0) {
      console.log(`‚ö†Ô∏è Batch vazio, pulando...`);
      return;
    }
    
    try {
      // 1. Filtrar licita√ß√µes ativas
      const licitacoesAbertas = this.filterByDataEncerramento(licitacoes);
      console.log(`üìÖ Filtradas: ${licitacoes.length} ‚Üí ${licitacoesAbertas.length} ativas`);
      
      if (licitacoesAbertas.length === 0) {
        this.processedCount += licitacoes.length;
        return;
      }
      
      // 2. Adicionar itens √†s licita√ß√µes
      const licitacoesComItens = await this.addItemsToLicitacoes(licitacoesAbertas);
      
      if (licitacoesComItens.length === 0) {
        this.processedCount += licitacoes.length;
        return;
      }
      
      // 3. Salvar no Supabase + Pinecone
      console.log(`üíæ Salvando ${licitacoesComItens.length} licita√ß√µes...`);
      const storageResult = await licitacaoStorageService.saveLicitacoes(licitacoesComItens);
      
      // Atualizar contadores
      this.supabaseSavedCount += storageResult.supabase;
      this.pineconeSavedCount += storageResult.pinecone;
      this.savedCount += storageResult.total;
      
      if (storageResult.success) {
        console.log(`‚úÖ Salvas: ${storageResult.total} (Supabase: ${storageResult.supabase}, Pinecone: ${storageResult.pinecone})`);
      } else {
        console.error(`‚ùå Erro no salvamento:`, storageResult.errors);
      }
      
      this.processedCount += licitacoes.length;
      
    } catch (error) {
      console.error(`‚ùå ERRO no processamento do batch:`, error);
      this.processedCount += licitacoes.length;
    }
  }

  private filterByDataEncerramento(licitacoes: any[]): any[] {
    // üéØ FILTRO DE DATA DE ENCERRAMENTO COM DEBUGGING DETALHADO
    const hoje = new Date();
    hoje.setHours(0, 0, 0, 0); // Reset horas para compara√ß√£o correta
    
    console.log(`üìÖ [FILTRO DEBUG] Data de hoje para compara√ß√£o: ${hoje.toISOString().split('T')[0]}`);
    console.log(`üìä [FILTRO DEBUG] Analisando ${licitacoes.length} licita√ß√µes...`);
    
    let semData = 0;
    let ativas = 0;
    let expiradas = 0;
    let errosProcessamento = 0;
    
    const amostrasLog: any[] = [];
    
    const licitacoesAtivas = licitacoes.filter((licitacao, index) => {
      // VERIFICAR APENAS DATA DE ENCERRAMENTO
      const dataEncerramento = licitacao.dataEncerramentoProposta;
      
      // Se n√£o tem data, considera ativa
      if (!dataEncerramento || dataEncerramento === '' || dataEncerramento === null) {
        semData++;
        if (amostrasLog.length < 3) {
          amostrasLog.push({
            id: licitacao.numeroControlePNCP || `licitacao-${index}`,
            dataEncerramento: 'SEM_DATA',
            status: 'ATIVA_SEM_DATA'
          });
        }
        return true;
      }
      
      try {
        // Converter para Date object para compara√ß√£o correta
        let dataEncerramentoObj: Date;
        let formatoDetectado = '';
        
        if (typeof dataEncerramento === 'string' && dataEncerramento.length === 8 && /^\d{8}$/.test(dataEncerramento)) {
          // YYYYMMDD
          const ano = parseInt(dataEncerramento.slice(0, 4));
          const mes = parseInt(dataEncerramento.slice(4, 6)) - 1; // Month 0-indexed
          const dia = parseInt(dataEncerramento.slice(6, 8));
          dataEncerramentoObj = new Date(ano, mes, dia);
          formatoDetectado = 'YYYYMMDD';
        } else if (typeof dataEncerramento === 'string' && dataEncerramento.includes('T')) {
          // ISO format with time (YYYY-MM-DDTHH:mm:ss)
          dataEncerramentoObj = new Date(dataEncerramento);
          formatoDetectado = 'ISO_WITH_TIME';
        } else if (typeof dataEncerramento === 'string' && dataEncerramento.includes('-')) {
          // YYYY-MM-DD
          dataEncerramentoObj = new Date(dataEncerramento);
          formatoDetectado = 'YYYY-MM-DD';
        } else {
          // Tentar convers√£o direta
          dataEncerramentoObj = new Date(dataEncerramento);
          formatoDetectado = 'CONVERSAO_DIRETA';
        }
        
        // Validar se a data foi convertida corretamente
        if (isNaN(dataEncerramentoObj.getTime())) {
          console.warn(`‚ö†Ô∏è [FILTRO] Data inv√°lida detectada: "${dataEncerramento}" (formato: ${formatoDetectado})`);
          errosProcessamento++;
          return true; // Considera ativa em caso de erro
        }
        
        const dataEncerramentoFormatada = dataEncerramentoObj.toISOString().split('T')[0];
        const isAtiva = dataEncerramentoObj > hoje;
        
        if (isAtiva) {
          ativas++;
        } else {
          expiradas++;
        }
        
        // Coletar amostras para log (primeiras 5)
        if (amostrasLog.length < 5) {
          amostrasLog.push({
            id: licitacao.numeroControlePNCP || `licitacao-${index}`,
            dataOriginal: dataEncerramento,
            formato: formatoDetectado,
            dataProcessada: dataEncerramentoFormatada,
            status: isAtiva ? 'ATIVA' : 'EXPIRADA',
            diasRestantes: Math.ceil((dataEncerramentoObj.getTime() - hoje.getTime()) / (1000 * 60 * 60 * 24))
          });
        }
        
        return isAtiva;
        
      } catch (error) {
        console.error(`‚ùå [FILTRO] Erro ao processar data "${dataEncerramento}":`, error);
        errosProcessamento++;
        return true; // Considera ativa em caso de erro
      }
    });
    
    // üìä LOG DETALHADO DOS RESULTADOS
    console.log(`üìä [FILTRO RESULTADO]:`);
    console.log(`  ‚úÖ Ativas: ${ativas}`);
    console.log(`  ‚ùå Expiradas: ${expiradas}`);
    console.log(`  ‚ö™ Sem data: ${semData}`);
    console.log(`  üö´ Erros: ${errosProcessamento}`);
    console.log(`  üìà Total aceitas: ${licitacoesAtivas.length}/${licitacoes.length}`);
    
    // üîç AMOSTRAS PARA DEBUGGING
    if (amostrasLog.length > 0) {
      console.log(`üîç [FILTRO AMOSTRAS]:`);
      amostrasLog.forEach((amostra, i) => {
        console.log(`  ${i + 1}. ${amostra.id}:`);
        console.log(`     Original: "${amostra.dataOriginal}" (${amostra.formato})`);
        console.log(`     Processada: ${amostra.dataProcessada}`);
        console.log(`     Status: ${amostra.status} (${amostra.diasRestantes} dias)`);
      });
    }
    
    return licitacoesAtivas;
  }

  // REMOVIDO: filterExistingInPinecone() - agora usa licitacaoStorageService.filterExistingLicitacoes()

  private async addItemsToLicitacoes(licitacoes: any[]): Promise<any[]> {
    try {
      // Reusar l√≥gica do adapter existente
      const resultado = await (this.adapter as any).adicionarItens(licitacoes);
      return resultado || [];
      
    } catch (error) {
      console.error(`‚ùå ERRO ao adicionar itens:`, error);
      // Retornar licita√ß√µes sem itens para n√£o travar o processo
      return licitacoes;
    }
  }

  private async fetchPage(modalidade: number, params: HistoricalMigrationParams, pagina: number) {
    const maxRetries = 3;
    const REQUEST_DELAY = 2500; // 2.5s (padronizado com adapter)
    
    for (let tentativa = 1; tentativa <= maxRetries; tentativa++) {
      const url = 'https://pncp.gov.br/api/consulta/v1/contratacoes/publicacao';
      
      const queryParams = new URLSearchParams({
        dataInicial: params.dataInicio,
        dataFinal: params.dataFim,
        codigoModalidadeContratacao: modalidade.toString(),
        pagina: pagina.toString()
      });
      
      const fullUrl = `${url}?${queryParams}`;
      
      // üï∞Ô∏è DELAY PADRONIZADO (mais conservador)
      await new Promise(resolve => setTimeout(resolve, REQUEST_DELAY));
      
      try {
        // Timeout de 60 segundos por request
        const timeoutPromise = new Promise<never>((_, reject) => {
          setTimeout(() => reject(new Error(`Timeout de 60s na p√°gina ${pagina}`)), 60000);
        });
        
        const fetchPromise = fetch(fullUrl, {
          headers: {
            'User-Agent': 'Alicit-Integration/2.0 (Sistema de An√°lise de Licita√ß√µes)',
            'Accept': 'application/json',
            'Accept-Language': 'pt-BR',
            'Connection': 'keep-alive',
            'Cache-Control': 'no-cache'
          }
        });
        
        const response = await Promise.race([fetchPromise, timeoutPromise]);
        
        // üìä TRATAMENTO ESPEC√çFICO DE C√ìDIGOS HTTP (alinhado com adapter)
        if (response.status === 204) {
          console.log(`üìÑ PNCP: Sem conte√∫do (204) - p√°gina ${pagina}`);
          return null;
        }
        
        if (response.status === 400) {
          console.warn(`‚ö†Ô∏è PNCP: Bad Request (400) - p√°gina ${pagina}`);
          return null;
        }
        
        if (response.status === 422) {
          console.warn(`‚ö†Ô∏è PNCP: Unprocessable Entity (422) - p√°gina ${pagina}`);
          return null;
        }
        
        // üîÑ RETRY PARA HTTP 500 (implementa√ß√£o robusta)
        if (response.status === 500) {
          if (tentativa < maxRetries) {
            const retryDelay = 3000 + (tentativa * 1000); // 3s, 4s, 5s
            console.warn(`‚ö†Ô∏è PNCP: HTTP 500 - p√°gina ${pagina}, tentativa ${tentativa}/${maxRetries}. Retry em ${retryDelay}ms...`);
            await new Promise(resolve => setTimeout(resolve, retryDelay));
            continue; // Tenta novamente
          } else {
            console.error(`‚ùå PNCP: HTTP 500 persistente ap√≥s ${maxRetries} tentativas - p√°gina ${pagina}`);
            return null;
          }
        }
        
        if (!response.ok) {
          console.warn(`‚ö†Ô∏è PNCP: HTTP ${response.status} - p√°gina ${pagina}`);
          return null;
        }

        const text = await response.text();
        
        if (!text.trim()) {
          console.warn(`‚ö†Ô∏è PNCP: Resposta vazia - p√°gina ${pagina}`);
          return null;
        }

        const parsed = JSON.parse(text);
        
        // üìä VALIDAR ESTRUTURA CONFORME DOCUMENTA√á√ÉO
        if (!parsed.data && parsed.totalRegistros === undefined) {
          console.warn(`‚ö†Ô∏è PNCP: Estrutura inv√°lida - p√°gina ${pagina}`);
          return null;
        }
        
        // ‚úÖ SUCESSO - retorna resultado
        console.log(`‚úÖ PNCP: P√°gina ${pagina} processada com sucesso (tentativa ${tentativa})`);
        return parsed;
        
      } catch (error: any) {
        if (error.message?.includes('Timeout')) {
          console.warn(`‚è±Ô∏è PNCP: Timeout p√°gina ${pagina}, tentativa ${tentativa}/${maxRetries}`);
        } else {
          console.error(`‚ùå PNCP: Erro p√°gina ${pagina}, tentativa ${tentativa}:`, error.message);
        }
        
        if (tentativa < maxRetries) {
          const retryDelay = Math.pow(2, tentativa) * 1000; // Backoff exponencial
          console.log(`üîÑ PNCP: Reagendando p√°gina ${pagina} para ${retryDelay}ms...`);
          await new Promise(resolve => setTimeout(resolve, retryDelay));
        }
      }
    }
    
    console.error(`üí• PNCP: Falha definitiva ap√≥s ${maxRetries} tentativas - p√°gina ${pagina}`);
    return null;
  }

  private sleep(ms: number): Promise<void> {
    return new Promise(resolve => setTimeout(resolve, ms));
  }
}

